[
  {
    "question": "What is the FINAL YEAR PROJECT REPORT Batch -2021?",
    "answer": "\nATHESTIA",
    "supporting_passages": [
      "  \nUSMAN  INSTITUTE  OF TECHNOLOGY  \nAffiliated  with NED  University  of Engineering  & Technology,  Karachi  \n \nDepartment  of Computer  Science  \nB.S. Software Engineering \nFINAL  YEAR  PROJECT  REPORT  \nBatch -2021  \n \nATHESTIA  \nClean  slate  application  using  Named  Data  Network  with Dilithium \nto enhance security in future internet technology  \n \n \nBy \n \n HAFSA  SHOAIB  21B-054-SE \n Muhammad  Asfiyan  21B-111-SE \n Muhammad  Amir  Jawed  21B-211-SE \n Muhammad  Latif     21B-029-SE \n \nSupervised  by \nDr. Farhan  Ahmed  Karim  \n \nST-13, Block  7, Gulshan -e-Iqbal,  Abul  Hasan  Isphahani  Road,  Opposite  Safari  Park,  P.O. Box 75300, \nKarachi, Pakistan."
    ]
  },
  {
    "question": "What does USMAN INSTITUTE OF TECHNOLOGY have in common with NED University of Engineering & Technology?",
    "answer": "Affiliated",
    "supporting_passages": [
      "  \nUSMAN  INSTITUTE  OF TECHNOLOGY  \nAffiliated  with NED  University  of Engineering  & Technology,  Karachi  \n \nDepartment  of Computer  Science  \nB.S. Software Engineering \nFINAL  YEAR  PROJECT  REPORT  \nBatch -2021  \n \nATHESTIA  \nClean  slate  application  using  Named  Data  Network  with Dilithium \nto enhance security in future internet technology  \n \n \nBy \n \n HAFSA  SHOAIB  21B-054-SE \n Muhammad  Asfiyan  21B-111-SE \n Muhammad  Amir  Jawed  21B-211-SE \n Muhammad  Latif     21B-029-SE \n \nSupervised  by \nDr. Farhan  Ahmed  Karim  \n \nST-13, Block  7, Gulshan -e-Iqbal,  Abul  Hasan  Isphahani  Road,  Opposite  Safari  Park,  P.O. Box 75300, \nKarachi, Pakistan."
    ]
  },
  {
    "question": "What is the name of the person who submitted the report?",
    "answer": "Dr. Farhan  Ahmed  Karim",
    "supporting_passages": [
      "Phone: 34978274 -5; 34994305; 34982476; http://www.uit.edu  \n\nSubmission  Performa  \n \nName  (1) .......................  HAFSA  SHOAIB  \nhafsashoaib989@gmail.com  \n0332 -2217868  \n(2) ........................  Muhammad  Asfiyan  \nasfiyanshivani0321@gmail.com  \n0321 -2904274  \n(3) ........................  Muhammad  Amir  Jawed  \namirjaved040@gmail.com  \n0327 -2471748  \n(4) ........................  Muhammad  Latif \nmoha mmadlatif786785@gmail.com  \n03032595932  \n \n \nAddress  (1) ......................  (House  No: A-44, Block  7, Saadi  Town)  \n(2) ........................  (44/2,  N lane,  phase  4, Near  Imambargah)  \n(3) ........................  (Flat#405,  4th Floor,  Rabia  Palace,  Kharadar)  \n(4) ........................  (Near  Bukhari  Masjid  , Azad  Muhallah,  Kemari  Town)  \n \n \n  \ni  ATHESTIA  - Clean  slate application  using  Named  Data Network  with Dilithium  to enhance  security \nin future internet technology  \n \nDr. Farhan  Ahmed  Karim  Signature  \n \n \n \n \nThis report  is submitted  as required  for the Project  in accordance  with the rules  laid down  by the Usman \nInstitute  of technology as part of  the requirements for the award of the degree of Bachelor Software \nEngineering . I declare  that the work  presented  in this report  is my own except  where  due reference  or \nacknowledgement is given to the work of others. Signatures  of students  Date \n \n \n(1) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  \u2026\u202630 -05-2025\u2026\u2026  \n(2) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026\u202630 -05-2025\u2026\u2026  \n(3) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  \u2026\u202630 -05-2025\u2026\u2026  \n(4) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  \u2026\u202630 -05-2025\u2026\u2026  \n \n \n \n."
    ]
  },
  {
    "question": "What is the name of the student who submitted the report?",
    "answer": "Dr. Farhan  Ahmed  Karim",
    "supporting_passages": [
      "Phone: 34978274 -5; 34994305; 34982476; http://www.uit.edu  \n\nSubmission  Performa  \n \nName  (1) .......................  HAFSA  SHOAIB  \nhafsashoaib989@gmail.com  \n0332 -2217868  \n(2) ........................  Muhammad  Asfiyan  \nasfiyanshivani0321@gmail.com  \n0321 -2904274  \n(3) ........................  Muhammad  Amir  Jawed  \namirjaved040@gmail.com  \n0327 -2471748  \n(4) ........................  Muhammad  Latif \nmoha mmadlatif786785@gmail.com  \n03032595932  \n \n \nAddress  (1) ......................  (House  No: A-44, Block  7, Saadi  Town)  \n(2) ........................  (44/2,  N lane,  phase  4, Near  Imambargah)  \n(3) ........................  (Flat#405,  4th Floor,  Rabia  Palace,  Kharadar)  \n(4) ........................  (Near  Bukhari  Masjid  , Azad  Muhallah,  Kemari  Town)  \n \n \n  \ni  ATHESTIA  - Clean  slate application  using  Named  Data Network  with Dilithium  to enhance  security \nin future internet technology  \n \nDr. Farhan  Ahmed  Karim  Signature  \n \n \n \n \nThis report  is submitted  as required  for the Project  in accordance  with the rules  laid down  by the Usman \nInstitute  of technology as part of  the requirements for the award of the degree of Bachelor Software \nEngineering . I declare  that the work  presented  in this report  is my own except  where  due reference  or \nacknowledgement is given to the work of others. Signatures  of students  Date \n \n \n(1) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  \u2026\u202630 -05-2025\u2026\u2026  \n(2) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026\u202630 -05-2025\u2026\u2026  \n(3) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  \u2026\u202630 -05-2025\u2026\u2026  \n(4) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  \u2026\u202630 -05-2025\u2026\u2026  \n \n \n \n."
    ]
  },
  {
    "question": "What did Allah grant us to complete our Final Year Project?",
    "answer": "strength , perseverance, and wisdom",
    "supporting_passages": [
      "ii  Acknowledgments  \n \nFirst, we would like to thank Allah for granting us strength , perseverance, and wisdom to \nsuccessfully complete our Final Year Project (FYP). Without His endless blessings, this \naccomplishment would not have been possible. Our heartfelt  gratitude  goes to our supervisor,  Dr. Farhan  Ahmed  Karim,  for his exceptional  guidance, \nconstant  support,  and insightful  feedback  throughout  this journey. His expertise  has been  instrumental \nin shaping the direction and success of our research. We are also sincerely  thankful  to our dedicated  team  members for their collaboration, hard  work,  and \ncommitment throughout the development of Athestia. Each member's contribution was vital to the \nprogress and completion of this project. A special  note of appreciation  goes to our famili es and friends for  their unwavering  support,  patience, \nand encouragement during the most challenging phases of this project. Their belief in us has been a \nsource of constant motivation. Lastly,  we extend  our gratitude  to everyone  who contributed  directly  or indirectly  to the completion  of \nthis project. We hope that our efforts through Athestia serve as a meaningful addition to the field of \nsecure networking technologies."
    ]
  },
  {
    "question": "What did Allah grant us to complete our final year project?",
    "answer": "strength , perseverance, and wisdom",
    "supporting_passages": [
      "ii  Acknowledgments  \n \nFirst, we would like to thank Allah for granting us strength , perseverance, and wisdom to \nsuccessfully complete our Final Year Project (FYP). Without His endless blessings, this \naccomplishment would not have been possible. Our heartfelt  gratitude  goes to our supervisor,  Dr. Farhan  Ahmed  Karim,  for his exceptional  guidance, \nconstant  support,  and insightful  feedback  throughout  this journey. His expertise  has been  instrumental \nin shaping the direction and success of our research. We are also sincerely  thankful  to our dedicated  team  members for their collaboration, hard  work,  and \ncommitment throughout the development of Athestia. Each member's contribution was vital to the \nprogress and completion of this project. A special  note of appreciation  goes to our famili es and friends for  their unwavering  support,  patience, \nand encouragement during the most challenging phases of this project. Their belief in us has been a \nsource of constant motivation. Lastly,  we extend  our gratitude  to everyone  who contributed  directly  or indirectly  to the completion  of \nthis project. We hope that our efforts through Athestia serve as a meaningful addition to the field of \nsecure networking technologies."
    ]
  },
  {
    "question": "What is the name of the project that focuses on developing a quantum -safe digital signature solution?",
    "answer": "Dilithium",
    "supporting_passages": [
      "iii  Abstract  \n \nThis project focuses on developing a quantum -safe digital signature solution using the post -quantum \nModule -Lattice -Based Digital Signature Standard algorithm (named as Dilithium), a lattice -based \ncryptographic method designed to withstand quantum computing threats. This project involves the \ndesigning  of a hardware  accelerator  for the Dilithium  digital  signature  operations  using  SystemVerilog. To simulate  the working of  Dilithium, we integrate  it with  the Named Data Network. Hence, the plan \nis to utilize the MiniNDN Framework which provides a l ightweight simulation environment for NDN  \nNetwork. Hence,  we modify  the NDN  self-certification  process  using  Dilithium. The project was  \nundertaken  by initially  implementing  and testing  the cryptographic functions  in Python, followed by \nthe hardware design using SystemVerilog. The Dilithium accelerator is ported onto Field \nProgrammable Gate Array (FPGA) platforms, which enables efficient key generation, signature \ncreation, and verification operations. Communication bet ween the FPGA and the miniNDN is \nfacilitated through the UART protocol. Extensive testing is conducted to validate the performance \nand security of the system, confirming that it meets post -quantum cryptographic standards. The \noutcome of this project  demons trates the feasibility of integrating post -quantum cryptographic \naccelerators within NDN, significantly improving the security of communication."
    ]
  },
  {
    "question": "What is the name of the project that focuses on developing a quantum safe digital signature solution?",
    "answer": "Dilithium",
    "supporting_passages": [
      "iii  Abstract  \n \nThis project focuses on developing a quantum -safe digital signature solution using the post -quantum \nModule -Lattice -Based Digital Signature Standard algorithm (named as Dilithium), a lattice -based \ncryptographic method designed to withstand quantum computing threats. This project involves the \ndesigning  of a hardware  accelerator  for the Dilithium  digital  signature  operations  using  SystemVerilog. To simulate  the working of  Dilithium, we integrate  it with  the Named Data Network. Hence, the plan \nis to utilize the MiniNDN Framework which provides a l ightweight simulation environment for NDN  \nNetwork. Hence,  we modify  the NDN  self-certification  process  using  Dilithium. The project was  \nundertaken  by initially  implementing  and testing  the cryptographic functions  in Python, followed by \nthe hardware design using SystemVerilog. The Dilithium accelerator is ported onto Field \nProgrammable Gate Array (FPGA) platforms, which enables efficient key generation, signature \ncreation, and verification operations. Communication bet ween the FPGA and the miniNDN is \nfacilitated through the UART protocol. Extensive testing is conducted to validate the performance \nand security of the system, confirming that it meets post -quantum cryptographic standards. The \noutcome of this project  demons trates the feasibility of integrating post -quantum cryptographic \naccelerators within NDN, significantly improving the security of communication."
    ]
  },
  {
    "question": "What is the name of the algorithm used for Athestia?",
    "answer": "Dilithium",
    "supporting_passages": [
      "Keywords : Dilithium, post -quantum cryptography, Named Data Networking, hardware accelerator, \ndigital signature s, quantum -safe, cryptography  \n \niv  Table  of contents  \n \n            Submission  Performa  ................................ ................................ ................................ ..........................  i \n            Acknowledgments  ................................ ................................ ................................ ..............................  ii \n            Abstract  ................................ ................................ ................................ ................................ .............  iii \nList of figures  ................................ ................................ ................................ ................................ ... vii \nList of tables  ................................ ................................ ................................ ................................ .... viii \n1. Introduction  ................................ ................................ ................................ ................................ .... 1 \n1.1. Introduction  ................................ ................................ ................................ .............................  1 \n1.2. Project  Overview  and Functionality  ................................ ................................ .......................  1 \n1.3. Relationship  with  Sustainable  Development  Goals  (SDGs)  ................................ ....................  4 \n1.4. Project  Breakdown  ................................ ................................ ................................ ..................  5 \n2. Background  and Literature  Review  ................................ ................................ ...............................  6 \n2.1 Background  ................................ ................................ ................................ .............................  6 \n2.2 Similar  Applications  ................................ ................................ ................................ ................  7 \n2.2.1. RSA -Based  Authentication  in NDN  ................................ ................................ ...............................  7 \n2.2.2  ECC  Integration  in Network  Security  ................................ ................................ ............................  7 \n2.2.3.  AES  in NDN  Data  Encryption  ................................ ................................ ................................ ....... 7 \n2.3. Algorithms  ................................ ................................ ................................ ...............................  8 \n2.3.1. Dilithium  Algorithms ................................ ................................ ................................ .....................  8 \n2.3.2. Why Choose  Dilithium  for Athestia? ................................ ................................ .............................  9 \n \n            3. Aim and Statement  of Problem  ................................ ................................ ................................ .... 11 \n3.1."
    ]
  },
  {
    "question": "What is the name of the algorithm used in Athestia?",
    "answer": "Dilithium",
    "supporting_passages": [
      "Keywords : Dilithium, post -quantum cryptography, Named Data Networking, hardware accelerator, \ndigital signature s, quantum -safe, cryptography  \n \niv  Table  of contents  \n \n            Submission  Performa  ................................ ................................ ................................ ..........................  i \n            Acknowledgments  ................................ ................................ ................................ ..............................  ii \n            Abstract  ................................ ................................ ................................ ................................ .............  iii \nList of figures  ................................ ................................ ................................ ................................ ... vii \nList of tables  ................................ ................................ ................................ ................................ .... viii \n1. Introduction  ................................ ................................ ................................ ................................ .... 1 \n1.1. Introduction  ................................ ................................ ................................ .............................  1 \n1.2. Project  Overview  and Functionality  ................................ ................................ .......................  1 \n1.3. Relationship  with  Sustainable  Development  Goals  (SDGs)  ................................ ....................  4 \n1.4. Project  Breakdown  ................................ ................................ ................................ ..................  5 \n2. Background  and Literature  Review  ................................ ................................ ...............................  6 \n2.1 Background  ................................ ................................ ................................ .............................  6 \n2.2 Similar  Applications  ................................ ................................ ................................ ................  7 \n2.2.1. RSA -Based  Authentication  in NDN  ................................ ................................ ...............................  7 \n2.2.2  ECC  Integration  in Network  Security  ................................ ................................ ............................  7 \n2.2.3.  AES  in NDN  Data  Encryption  ................................ ................................ ................................ ....... 7 \n2.3. Algorithms  ................................ ................................ ................................ ...............................  8 \n2.3.1. Dilithium  Algorithms ................................ ................................ ................................ .....................  8 \n2.3.2. Why Choose  Dilithium  for Athestia? ................................ ................................ .............................  9 \n \n            3. Aim and Statement  of Problem  ................................ ................................ ................................ .... 11 \n3.1."
    ]
  },
  {
    "question": "What is the definition of the problem?",
    "answer": "End Users",
    "supporting_passages": [
      "Statement  of the Problem  ................................ ................................ ................................ ...... 11 \n3.1.1. Cryptographic  Vulnerabilities  to Quantum  Computing  ................................ ................................ 11 \n3.1.2. Challenges  in Secure  Data  Distribution  with Named  Data Networking (NDN)  ............................ 12 \n3.2. Scope  and Stakeholders  ................................ ................................ ................................ .........  12 \n3.2.1. Researchers  and Developers  ................................ ................................ ................................ ......... 12 \n3.2.2. End Users  ................................ ................................ ................................ ................................ .....12 \n3.3 Approach  to Tackling  the Problem  ................................ ................................ .......................  13 \n3.3.1. Integration  of Dilithium  for Secure  Authentication  ................................ ................................ ......13 \n4. Hardware,  Software  analysis  and requirements  ................................ ................................ ..........  14 \n4.1. Fact-Finding  Techniques  ................................ ................................ ................................ ....... 14 \n4.2. Hardware  Analysis  and Requirements  ................................ ................................ .................  14 \n4.2.1. Xilinx  Zynq -7000  SoC ................................ ................................ ................................ .................. 14 \n4.2.2. Intel  (Altera)  Cyclone  V FPGA  ................................ ................................ ................................ .....14 \n4.2.3. Arty-7 FPGA  (Chosen)  ................................ ................................ ................................ ................. 14 \n4.3. Software  Analysis  and Requirements  ................................ ................................ ...................  15 \n4.4. System  Structure  ................................ ................................ ................................ ...................  15 \n4.4.1. Actor  Use Case  Diagram  ................................ ................................ ................................ .............. 18 \n4.4.3. Operational  Diagram ................................ ................................ ................................ ......................... 23 \n4.5. Requirements ................................ ................................ ................................ .........................  25 \n \nv  4.5.1. Functional  Requirements  ................................ ................................ ................................ ............. 25 \n4.5.2. Non-Functional  Requirements  ................................ ................................ ................................ .....26 \n5."
    ]
  },
  {
    "question": "What is the definition of a problem?",
    "answer": "End Users",
    "supporting_passages": [
      "Statement  of the Problem  ................................ ................................ ................................ ...... 11 \n3.1.1. Cryptographic  Vulnerabilities  to Quantum  Computing  ................................ ................................ 11 \n3.1.2. Challenges  in Secure  Data  Distribution  with Named  Data Networking (NDN)  ............................ 12 \n3.2. Scope  and Stakeholders  ................................ ................................ ................................ .........  12 \n3.2.1. Researchers  and Developers  ................................ ................................ ................................ ......... 12 \n3.2.2. End Users  ................................ ................................ ................................ ................................ .....12 \n3.3 Approach  to Tackling  the Problem  ................................ ................................ .......................  13 \n3.3.1. Integration  of Dilithium  for Secure  Authentication  ................................ ................................ ......13 \n4. Hardware,  Software  analysis  and requirements  ................................ ................................ ..........  14 \n4.1. Fact-Finding  Techniques  ................................ ................................ ................................ ....... 14 \n4.2. Hardware  Analysis  and Requirements  ................................ ................................ .................  14 \n4.2.1. Xilinx  Zynq -7000  SoC ................................ ................................ ................................ .................. 14 \n4.2.2. Intel  (Altera)  Cyclone  V FPGA  ................................ ................................ ................................ .....14 \n4.2.3. Arty-7 FPGA  (Chosen)  ................................ ................................ ................................ ................. 14 \n4.3. Software  Analysis  and Requirements  ................................ ................................ ...................  15 \n4.4. System  Structure  ................................ ................................ ................................ ...................  15 \n4.4.1. Actor  Use Case  Diagram  ................................ ................................ ................................ .............. 18 \n4.4.3. Operational  Diagram ................................ ................................ ................................ ......................... 23 \n4.5. Requirements ................................ ................................ ................................ .........................  25 \n \nv  4.5.1. Functional  Requirements  ................................ ................................ ................................ ............. 25 \n4.5.2. Non-Functional  Requirements  ................................ ................................ ................................ .....26 \n5."
    ]
  },
  {
    "question": "What are the key features of Architecture?",
    "answer": "analysis  and complexity",
    "supporting_passages": [
      "Software  design  and modeling  ................................ ................................ ................................ ...... 27 \n5.1. Project  Architecture  ................................ ................................ ................................ ..............  27 \n5.1.1. Main  Components:  ................................ ................................ ................................ ....................... 27 \n5.1.2. Key Features  of Architecture:  ................................ ................................ ................................ .......28 \n5.2. Architecture  Used:  ................................ ................................ ................................ ................  28 \n5.2.1. Hardware  Layer  ................................ ................................ ................................ ........................... 29 \n5.2.2. Middleware  Layer ................................ ................................ ................................ ......................... 29 \n5.3. Design  Diagrams:  ................................ ................................ ................................ ..................  30 \n5.3.1. Object  Diagram  ................................ ................................ ................................ ............................ 30 \nThe object diagram provides a snapshot of the system at runtime, focusing on the objects involved  .......... 30 \nand their relationships during operation. ................................ ................................ ................................ ...30 \n5.3.2. Class  Diagram  ................................ ................................ ................................ .............................. 32 \n5.4. Behavioral  Diagrams  ................................ ................................ ................................ .............  34 \n5.4.1. Sequence  Diagram  ................................ ................................ ................................ ....................... 35 \n5.5. User  Interface  Design  ................................ ................................ ................................ ............  36 \n6. Algorithm  analysis  and complexity  ................................ ................................ ..............................  40 \n6.1. Introduction  ................................ ................................ ................................ ...........................  40 \n6.2. Dilithium  Algorithms ................................ ................................ ................................ .............  40 \n6.2.1. Purpose  and Significance  ................................ ................................ ................................ ............. 40 \n6.2.2. Pseudocode  and Operation  ................................ ................................ ................................ ........... 41 \n6.3. COMPLEXITY  ANALYSIS  AND  OPTIMIZATION  ................................ .........................  45 \n6.3.1. Time  Complexity  ................................ ................................ ................................ .......................... 45 \n6.3.2."
    ]
  },
  {
    "question": "What is a key feature of Architecture?",
    "answer": "analysis  and complexity",
    "supporting_passages": [
      "Software  design  and modeling  ................................ ................................ ................................ ...... 27 \n5.1. Project  Architecture  ................................ ................................ ................................ ..............  27 \n5.1.1. Main  Components:  ................................ ................................ ................................ ....................... 27 \n5.1.2. Key Features  of Architecture:  ................................ ................................ ................................ .......28 \n5.2. Architecture  Used:  ................................ ................................ ................................ ................  28 \n5.2.1. Hardware  Layer  ................................ ................................ ................................ ........................... 29 \n5.2.2. Middleware  Layer ................................ ................................ ................................ ......................... 29 \n5.3. Design  Diagrams:  ................................ ................................ ................................ ..................  30 \n5.3.1. Object  Diagram  ................................ ................................ ................................ ............................ 30 \nThe object diagram provides a snapshot of the system at runtime, focusing on the objects involved  .......... 30 \nand their relationships during operation. ................................ ................................ ................................ ...30 \n5.3.2. Class  Diagram  ................................ ................................ ................................ .............................. 32 \n5.4. Behavioral  Diagrams  ................................ ................................ ................................ .............  34 \n5.4.1. Sequence  Diagram  ................................ ................................ ................................ ....................... 35 \n5.5. User  Interface  Design  ................................ ................................ ................................ ............  36 \n6. Algorithm  analysis  and complexity  ................................ ................................ ..............................  40 \n6.1. Introduction  ................................ ................................ ................................ ...........................  40 \n6.2. Dilithium  Algorithms ................................ ................................ ................................ .............  40 \n6.2.1. Purpose  and Significance  ................................ ................................ ................................ ............. 40 \n6.2.2. Pseudocode  and Operation  ................................ ................................ ................................ ........... 41 \n6.3. COMPLEXITY  ANALYSIS  AND  OPTIMIZATION  ................................ .........................  45 \n6.3.1. Time  Complexity  ................................ ................................ ................................ .......................... 45 \n6.3.2."
    ]
  },
  {
    "question": "What is the name of the program that is used to test the system?",
    "answer": "Technical  Feasibility  and Evaluation",
    "supporting_passages": [
      "Space  Complexity  ................................ ................................ ................................ ......................... 46 \n6.4. Discussion  ................................ ................................ ................................ ..............................  46 \n7. Implementation  ................................ ................................ ................................ .............................  47 \n7.1. CODE  ................................ ................................ ................................ ................................ .... 47 \n7.1.1.  main.py  ................................ ................................ ................................ ................................ ........ 47 \n7.1.2. Key_internal.sv  ................................ ................................ ................................ ............................. 47 \n7.2. Component  Diagram  ................................ ................................ ................................ .............  52 \n7.3 Deployment  Diagram  ................................ ................................ ................................ ............  54 \n8. Testing  ................................ ................................ ................................ ................................ ...........  56 \n8.1. TESTING  METHODS  ................................ ................................ ................................ ..........  56 \n8.1.1. White -box testing:  ................................ ................................ ................................ ........................ 56 \n8.1.2. Black -box testing  ................................ ................................ ................................ .......................... 60 \n9. Discussion  ................................ ................................ ................................ ................................ ...... 63 \n9.1. Core  Contributions  and Impact  ................................ ................................ ............................  63 \n9.2. Technical  Feasibility  and Evaluation  ................................ ................................ ....................  63 \n9.3. System  Integration  and Interoperability ................................ ................................ ...............  63 \n9.4. Challenges  Faced  ................................ ................................ ................................ ...................  64 \n10. Conclusion  ................................ ................................ ................................ .............................  65 \n \nvi  11. Future  Work  ................................ ................................ ................................ ..........................  66 \n11.1. Integration  of Kyber  for Secure  Key Exchange ................................ .............................  66 \n11.2. Real -World  Deployment  and Evaluation  ................................ ................................ ....... 66 \n12. Achievement  ................................ ................................ ................................ ..........................  67 \n13."
    ]
  },
  {
    "question": "What is the name of the tool that is used to test the system?",
    "answer": "Technical  Feasibility  and Evaluation",
    "supporting_passages": [
      "Space  Complexity  ................................ ................................ ................................ ......................... 46 \n6.4. Discussion  ................................ ................................ ................................ ..............................  46 \n7. Implementation  ................................ ................................ ................................ .............................  47 \n7.1. CODE  ................................ ................................ ................................ ................................ .... 47 \n7.1.1.  main.py  ................................ ................................ ................................ ................................ ........ 47 \n7.1.2. Key_internal.sv  ................................ ................................ ................................ ............................. 47 \n7.2. Component  Diagram  ................................ ................................ ................................ .............  52 \n7.3 Deployment  Diagram  ................................ ................................ ................................ ............  54 \n8. Testing  ................................ ................................ ................................ ................................ ...........  56 \n8.1. TESTING  METHODS  ................................ ................................ ................................ ..........  56 \n8.1.1. White -box testing:  ................................ ................................ ................................ ........................ 56 \n8.1.2. Black -box testing  ................................ ................................ ................................ .......................... 60 \n9. Discussion  ................................ ................................ ................................ ................................ ...... 63 \n9.1. Core  Contributions  and Impact  ................................ ................................ ............................  63 \n9.2. Technical  Feasibility  and Evaluation  ................................ ................................ ....................  63 \n9.3. System  Integration  and Interoperability ................................ ................................ ...............  63 \n9.4. Challenges  Faced  ................................ ................................ ................................ ...................  64 \n10. Conclusion  ................................ ................................ ................................ .............................  65 \n \nvi  11. Future  Work  ................................ ................................ ................................ ..........................  66 \n11.1. Integration  of Kyber  for Secure  Key Exchange ................................ .............................  66 \n11.2. Real -World  Deployment  and Evaluation  ................................ ................................ ....... 66 \n12. Achievement  ................................ ................................ ................................ ..........................  67 \n13."
    ]
  },
  {
    "question": "What is the name of the reference to the system diagram of Athestia?",
    "answer": "1.1",
    "supporting_passages": [
      "Appendic es................................ ................................ ................................ .............................  68 \nReferences  ................................ ................................ ................................ ................................ ........  72 \n \n \nvii  List of figures  \n \nFigure  1.1 System  Diagram  of Athestia  ................................ ................................ ............  2 \nFigure  4.2 Actor Use Case Diagram  ................................ ................................ .................  18 \nFigure  4.3 Activity Swim Lane Diagram of Athestia  ................................ ........................  20 \nFigure  4.4 Operational Diagram  ................................ ................................ .......................  23 \nFigure  5.1 Object  Diagram  ................................ ................................ ................................ 31 \nFigure  5.2 Class  Diagram  ................................ ................................ ................................ ..32 \nFigure  5.3 Sequence  Diagram  ................................ ................................ ..........................  35 \nFigure  5.5 User  Interface  Design  Layout  ................................ ................................ .........   36 \nFigure  7.1 Component  Diagram  ................................ ................................ .......................   52 \nFigure  7.2 Deployment  Diagram  ................................ ................................ ......................   54 \n \nviii  List of tables  \nTable  2.1 Comparison  Table  of Existing Solutions  ................................ ..............................  08 \nTable  8.1.1.1  Unit Testing. ................................ ................................ ................................ ...... 57 \nTable  8.1.1.2  Integration  Testing. ................................ ................................ ............................  59 \nTable  8.1.1.3  System  Testing. ................................ ................................ ................................ . 60 \nTable  8.1.2  Black -box Testing."
    ]
  },
  {
    "question": "What are the references to Athestia?",
    "answer": "Figure  1.1 System  Diagram",
    "supporting_passages": [
      "Appendic es................................ ................................ ................................ .............................  68 \nReferences  ................................ ................................ ................................ ................................ ........  72 \n \n \nvii  List of figures  \n \nFigure  1.1 System  Diagram  of Athestia  ................................ ................................ ............  2 \nFigure  4.2 Actor Use Case Diagram  ................................ ................................ .................  18 \nFigure  4.3 Activity Swim Lane Diagram of Athestia  ................................ ........................  20 \nFigure  4.4 Operational Diagram  ................................ ................................ .......................  23 \nFigure  5.1 Object  Diagram  ................................ ................................ ................................ 31 \nFigure  5.2 Class  Diagram  ................................ ................................ ................................ ..32 \nFigure  5.3 Sequence  Diagram  ................................ ................................ ..........................  35 \nFigure  5.5 User  Interface  Design  Layout  ................................ ................................ .........   36 \nFigure  7.1 Component  Diagram  ................................ ................................ .......................   52 \nFigure  7.2 Deployment  Diagram  ................................ ................................ ......................   54 \n \nviii  List of tables  \nTable  2.1 Comparison  Table  of Existing Solutions  ................................ ..............................  08 \nTable  8.1.1.1  Unit Testing. ................................ ................................ ................................ ...... 57 \nTable  8.1.1.2  Integration  Testing. ................................ ................................ ............................  59 \nTable  8.1.1.3  System  Testing. ................................ ................................ ................................ . 60 \nTable  8.1.2  Black -box Testing."
    ]
  },
  {
    "question": "What is an example of a UML symbol?",
    "answer": "Lollipop",
    "supporting_passages": [
      "................................ ................................ .............................  61 \n \nix  List of symbols  and Units  \n \nNotation  Symbol  Description  \nClass  Rectangle  Represents  a class  with attributes  and methods  \nObject  Rectangle  with name  Instance  of a class \nActor  Stick  figure  External  entity  that interacts with  the system  \nUse Case  Oval  Describes  a system  function  or service  \nAssociation  Solid line Connection between actor and use case or between \nclasses  \nDependency  Dashed  arrow  One element  depends  on another  \nGeneralization  Solid  arrow  with \nhollow triangle  Shows  inheritance  between  classes  \nAggregation  Hollow  diamond  A whole -part relationship  where  part can exist \nindependently  \nComposition  Solid  diamond  A strong  whole -part relationship  (part  cannot  exist \nwithout whole)  \nSequence  Diagram \nLifeline  Vertical  dashed  line Represents  the time span during  which  an object \nexists  \nMessage  Call Solid  arrow  Represents  a message  sent from  one object  to another  \nReturn Message  Dashed  arrow  Represents  the return  of control/data  after a call \nComponent  Rectangle  with tabs Represents  modular  part of a system  (e.g.,  FPGA \nmodule, NDN emulator)  \nInterface \n(Realization)  Lollipop  symbol  Shows  the provided  interface  of a component  \nDeployment  Node  Cube  Represents  a physical  hardware  or environment \nwhere components are deployed  \nArtifact  Document  symbol  Represents  a software  artifact  (like code,  libraries) \ndeployed on a node  \nPackage  Tabbed  folder icon Groups  related  UML  elements  into a single \nnamespace ."
    ]
  },
  {
    "question": "What is the name of the symbol used to represent a component?",
    "answer": "Lollipop",
    "supporting_passages": [
      "................................ ................................ .............................  61 \n \nix  List of symbols  and Units  \n \nNotation  Symbol  Description  \nClass  Rectangle  Represents  a class  with attributes  and methods  \nObject  Rectangle  with name  Instance  of a class \nActor  Stick  figure  External  entity  that interacts with  the system  \nUse Case  Oval  Describes  a system  function  or service  \nAssociation  Solid line Connection between actor and use case or between \nclasses  \nDependency  Dashed  arrow  One element  depends  on another  \nGeneralization  Solid  arrow  with \nhollow triangle  Shows  inheritance  between  classes  \nAggregation  Hollow  diamond  A whole -part relationship  where  part can exist \nindependently  \nComposition  Solid  diamond  A strong  whole -part relationship  (part  cannot  exist \nwithout whole)  \nSequence  Diagram \nLifeline  Vertical  dashed  line Represents  the time span during  which  an object \nexists  \nMessage  Call Solid  arrow  Represents  a message  sent from  one object  to another  \nReturn Message  Dashed  arrow  Represents  the return  of control/data  after a call \nComponent  Rectangle  with tabs Represents  modular  part of a system  (e.g.,  FPGA \nmodule, NDN emulator)  \nInterface \n(Realization)  Lollipop  symbol  Shows  the provided  interface  of a component  \nDeployment  Node  Cube  Represents  a physical  hardware  or environment \nwhere components are deployed  \nArtifact  Document  symbol  Represents  a software  artifact  (like code,  libraries) \ndeployed on a node  \nPackage  Tabbed  folder icon Groups  related  UML  elements  into a single \nnamespace ."
    ]
  },
  {
    "question": "What is the name of the project Athestia?",
    "answer": "\naddresses these emerging threats by designing a quantum -safe digital signature solution",
    "supporting_passages": [
      "1  1. Introduction  \n \n1.1. Introduction  \nThe rapid  advancements  in quantum  computing  present  a significant  threat  to traditional  cryptographic \nsystems, which rely on mathematical problems that quantum algorithms can potentially solve \nefficiently. Algorithms like RSA and ECC, which have been widely used to secure communications \nfor decades,  are at risk of being  compromise d by quantum  computers [1]. This project,  titled  Athestia , \naddresses these emerging threats by designing a quantum -safe digital signature solution using \nDilithium, a lattice -based digital signature algorithm, has been selected by the National Institute of \nStandards and Technology (NIST) for post -quantum cryptogr aphy standardization due to its strong \nfoundations, which rely on difficult computational problems in lattice cryptography. Lattice -based \nschemes, such as Dilithium, provide security by solving complex mathematical problems like the \nShortest Vector Problem  (SVP) and the Learning with Errors (LWE) problem, which are \ncomputationally infeasible to solve efficiently, even with the capabilities of quantum computers. Named Data Networking (NDN), an  emerging data -centric communication model, changes  the focus \nof network communication from the location of data (IP addresses) to the content itself."
    ]
  },
  {
    "question": "What is Athestia's goal?",
    "answer": "designing a quantum -safe digital signature solution",
    "supporting_passages": [
      "1  1. Introduction  \n \n1.1. Introduction  \nThe rapid  advancements  in quantum  computing  present  a significant  threat  to traditional  cryptographic \nsystems, which rely on mathematical problems that quantum algorithms can potentially solve \nefficiently. Algorithms like RSA and ECC, which have been widely used to secure communications \nfor decades,  are at risk of being  compromise d by quantum  computers [1]. This project,  titled  Athestia , \naddresses these emerging threats by designing a quantum -safe digital signature solution using \nDilithium, a lattice -based digital signature algorithm, has been selected by the National Institute of \nStandards and Technology (NIST) for post -quantum cryptogr aphy standardization due to its strong \nfoundations, which rely on difficult computational problems in lattice cryptography. Lattice -based \nschemes, such as Dilithium, provide security by solving complex mathematical problems like the \nShortest Vector Problem  (SVP) and the Learning with Errors (LWE) problem, which are \ncomputationally infeasible to solve efficiently, even with the capabilities of quantum computers. Named Data Networking (NDN), an  emerging data -centric communication model, changes  the focus \nof network communication from the location of data (IP addresses) to the content itself."
    ]
  },
  {
    "question": "What is the goal of the project?",
    "answer": "develop a secure cryptographic framework that is \nresistant to quant um attacks",
    "supporting_passages": [
      "NDN \ninherently  provides  efficient  data distribution  by caching  data within  the network,  reducing  server  load \nand speeding up data access. The project involves the designing of a hardware accelerator for the Dilithium digital signature \noperations,  flashed  on FPGA  platforms;  to simulate  the working  of Dilithium,  we integrate  it with the  \nNDN  Network. Hence,  the plan is to utilize  the MiniNDN  Framework  which  provides  a lightweight \nsimulation  environment  for NDN  Network. So, we are modifying  the self-certification  process  of NDN \nwith Dilithium to enhance security. The goal is to develop a secure cryptographic framework that is \nresistant to quant um attacks. 1.2. Project  Overview  and Functionality  \nThe primary function of this project is to develop a hardware accelerator for the Dilithium digital \nsignature  operations. This accelerator  is designed  to perform  key generation,  signature,  and verification \noperations, all  of which  are fundamental  for secure  communication  in the face  of quantum  threats. By \nporting the Dilithium accelerator onto FPGA platforms, the project aims to ensure both security and \n \n2  efficiency in digital communications, enhancing the sys tem's performance compared to purely \nsoftware -based implementations."
    ]
  },
  {
    "question": "What is the main goal of the project?",
    "answer": "develop a secure cryptographic framework that is \nresistant to quant um attacks",
    "supporting_passages": [
      "NDN \ninherently  provides  efficient  data distribution  by caching  data within  the network,  reducing  server  load \nand speeding up data access. The project involves the designing of a hardware accelerator for the Dilithium digital signature \noperations,  flashed  on FPGA  platforms;  to simulate  the working  of Dilithium,  we integrate  it with the  \nNDN  Network. Hence,  the plan is to utilize  the MiniNDN  Framework  which  provides  a lightweight \nsimulation  environment  for NDN  Network. So, we are modifying  the self-certification  process  of NDN \nwith Dilithium to enhance security. The goal is to develop a secure cryptographic framework that is \nresistant to quant um attacks. 1.2. Project  Overview  and Functionality  \nThe primary function of this project is to develop a hardware accelerator for the Dilithium digital \nsignature  operations. This accelerator  is designed  to perform  key generation,  signature,  and verification \noperations, all  of which  are fundamental  for secure  communication  in the face  of quantum  threats. By \nporting the Dilithium accelerator onto FPGA platforms, the project aims to ensure both security and \n \n2  efficiency in digital communications, enhancing the sys tem's performance compared to purely \nsoftware -based implementations."
    ]
  },
  {
    "question": "What is the main function of the miniNDN framework?",
    "answer": "ensure  secure  and efficient communication",
    "supporting_passages": [
      "Figure  1.1 System  Diagram  of Athestia  \n \nFigure  1.1 illustrates  the architecture  and interaction  between  the miniNDN  (Named  Data  Networking) \nframework  and the Dilithium  Accelerator  to ensure  secure  and efficient communication  through  post- \nquantum cryptographic methods. 3  \u25cf MiniNDN  Framework:  \na. The NDN framework  is depicted  with Producers, Consumers, and  Routers  that facilitate \nthe exchange of data packets. b. The Certificate Authority  (CA) issues  certificates  to secure network  interactions. Data \npackets travel through routers, allowing consumers to retrieve information from \nproducers. \u25cf UART  Protocol:  \na. The Universal  Asynchronous  Receiver -Transmitter  (UART)  protocol  is used to bridge \ncommunication between the miniNDN framework and the Dilithium Accelerator, \nenabling data exchange for cryptographic operations. \u25cf Dilithium  Accelerator:  \na. The Dilithium  Accelerator  performs  critical  cryptographic  operations  such as key \ngeneration, signing, and verification of data packets. i. Decoder:  Decodes  incoming  requests  or data packets  from  the miniNDN  \nframework. ii. Memory  Controller:  Manages  the memory  operations  required  for \ncryptographic key storage and retrieval. iii. Control  Unit:  Direc ts the overall  operation  of the accelerator,  coordinating  tasks \nlike key generation, signing, and verifying. \u25cf Cryptographic  Operations:  \na. Key Generation:  Produces  public  and private  keys for signature  and verification. b."
    ]
  },
  {
    "question": "What is the name of the miniNDN framework?",
    "answer": "Dilithium  Accelerator",
    "supporting_passages": [
      "Figure  1.1 System  Diagram  of Athestia  \n \nFigure  1.1 illustrates  the architecture  and interaction  between  the miniNDN  (Named  Data  Networking) \nframework  and the Dilithium  Accelerator  to ensure  secure  and efficient communication  through  post- \nquantum cryptographic methods. 3  \u25cf MiniNDN  Framework:  \na. The NDN framework  is depicted  with Producers, Consumers, and  Routers  that facilitate \nthe exchange of data packets. b. The Certificate Authority  (CA) issues  certificates  to secure network  interactions. Data \npackets travel through routers, allowing consumers to retrieve information from \nproducers. \u25cf UART  Protocol:  \na. The Universal  Asynchronous  Receiver -Transmitter  (UART)  protocol  is used to bridge \ncommunication between the miniNDN framework and the Dilithium Accelerator, \nenabling data exchange for cryptographic operations. \u25cf Dilithium  Accelerator:  \na. The Dilithium  Accelerator  performs  critical  cryptographic  operations  such as key \ngeneration, signing, and verification of data packets. i. Decoder:  Decodes  incoming  requests  or data packets  from  the miniNDN  \nframework. ii. Memory  Controller:  Manages  the memory  operations  required  for \ncryptographic key storage and retrieval. iii. Control  Unit:  Direc ts the overall  operation  of the accelerator,  coordinating  tasks \nlike key generation, signing, and verifying. \u25cf Cryptographic  Operations:  \na. Key Generation:  Produces  public  and private  keys for signature  and verification. b."
    ]
  },
  {
    "question": "Athestia integrates Dilithium, a post -quantum cryptog raphic digital signature algorithm, within the Named Data Networking (NDN) framework.",
    "answer": "secure and future -proof communication systems",
    "supporting_passages": [
      "Signature:  The signature  unit signs  data packets  to guarantee  integrity  and authenticity. c. Verifier:  Verifies  signatures  using  public  keys to ensure  data authenticity  and security. This architecture demonstrates the seamless integration of  the Dilithium  post-quantum  cryptographic \naccelerator with the miniNDN framework, ensuring robust security for future network \ncommunications. 4  1.3. Relationship  with  Sustainable  Development  Goals  (SDGs)  \nThis project contributes directly to Goal 9: Industry, Innovation,  and Infrastructure of the 17 \nSustainable Development Goals (SDGs) established by the United Nations. Goal 9 emphasizes the \nimportance of building resilient infrastructure, promoting inclusive and sustainable industrialization, \nand fostering innovation. In  the era of rapid technological advancement and increasing global \ninterconnectivity, cybersecurity has become a fundamental component of sustainable digital \ninfrastructure. The implementation of Athestia, which integrates Dilithium, a post -quantum cryptog raphic digital \nsignature algorithm, within the Named Data Networking (NDN) framework, directly addresses the \nemerging need for secure and future -proof communication systems. The threat posed by quantum \ncomputing to traditional encryption methods, such as R SA and ECC, is well documented. By \nproactively developing a quantum -resistant cryptographic solution, this project safeguards critical \ncommunication  channels against future quantum -based threats, ensuring the long -term resilience and \nreliability of digital  systems."
    ]
  },
  {
    "question": "Athestia integrates Dilithium, a post -quantum cryptog raphic digital signature algorithm, within the Named Data Networking framework.",
    "answer": "secure and future -proof communication systems",
    "supporting_passages": [
      "Signature:  The signature  unit signs  data packets  to guarantee  integrity  and authenticity. c. Verifier:  Verifies  signatures  using  public  keys to ensure  data authenticity  and security. This architecture demonstrates the seamless integration of  the Dilithium  post-quantum  cryptographic \naccelerator with the miniNDN framework, ensuring robust security for future network \ncommunications. 4  1.3. Relationship  with  Sustainable  Development  Goals  (SDGs)  \nThis project contributes directly to Goal 9: Industry, Innovation,  and Infrastructure of the 17 \nSustainable Development Goals (SDGs) established by the United Nations. Goal 9 emphasizes the \nimportance of building resilient infrastructure, promoting inclusive and sustainable industrialization, \nand fostering innovation. In  the era of rapid technological advancement and increasing global \ninterconnectivity, cybersecurity has become a fundamental component of sustainable digital \ninfrastructure. The implementation of Athestia, which integrates Dilithium, a post -quantum cryptog raphic digital \nsignature algorithm, within the Named Data Networking (NDN) framework, directly addresses the \nemerging need for secure and future -proof communication systems. The threat posed by quantum \ncomputing to traditional encryption methods, such as R SA and ECC, is well documented. By \nproactively developing a quantum -resistant cryptographic solution, this project safeguards critical \ncommunication  channels against future quantum -based threats, ensuring the long -term resilience and \nreliability of digital  systems."
    ]
  },
  {
    "question": "What is the main focus of the NDN project?",
    "answer": "content",
    "supporting_passages": [
      "Furthermore,  this project encourages  technological innovation  by introducing clean -slate architecture \nthrough NDN, which itself is a revolutionary shift from traditional IP -based communication models. By focusing  on content  rather  than location,  NDN  offers  a more  efficient  and secure  data transmission \napproach. Integrating this model with post -quantum security mechanisms not only protects \ninformation but also opens doors for next -generation internet architecture, making this project a \ncornerstone  in the evolution of secure, intelligent, and scalable digital infrastructures. From an industrial perspective, the design and implementation of a hardware -based cryptographic \naccelerator using FPGA technology contributes to the advancement of secure embe dded systems. These systems can be utilized across a wide range of sectors, including finance, healthcare, defense, \nand telecommunications, where data security is paramount. By ensuring that such systems are \nquantum -safe, the project  helps  industries  futur e-proof  their technologies,  thereby  fostering  sustainable \nindustrial growth aligned with SDG targets. 5  1.4. Project  Breakdown  \nThe project  has been divided into several  subprojects:  \n \n1. Designing of a hardware accelerator for the Dilithium  digital signature operations using \nSystemVerilog, which includes key generation, signature, and verification algorithms. 2. Port the Dilithium  accelerator  onto Field  Programmable  Gate  Array  (FPGA) platforms. 3."
    ]
  },
  {
    "question": "What is the main goal of the NDN project?",
    "answer": "encourages  technological innovation",
    "supporting_passages": [
      "Furthermore,  this project encourages  technological innovation  by introducing clean -slate architecture \nthrough NDN, which itself is a revolutionary shift from traditional IP -based communication models. By focusing  on content  rather  than location,  NDN  offers  a more  efficient  and secure  data transmission \napproach. Integrating this model with post -quantum security mechanisms not only protects \ninformation but also opens doors for next -generation internet architecture, making this project a \ncornerstone  in the evolution of secure, intelligent, and scalable digital infrastructures. From an industrial perspective, the design and implementation of a hardware -based cryptographic \naccelerator using FPGA technology contributes to the advancement of secure embe dded systems. These systems can be utilized across a wide range of sectors, including finance, healthcare, defense, \nand telecommunications, where data security is paramount. By ensuring that such systems are \nquantum -safe, the project  helps  industries  futur e-proof  their technologies,  thereby  fostering  sustainable \nindustrial growth aligned with SDG targets. 5  1.4. Project  Breakdown  \nThe project  has been divided into several  subprojects:  \n \n1. Designing of a hardware accelerator for the Dilithium  digital signature operations using \nSystemVerilog, which includes key generation, signature, and verification algorithms. 2. Port the Dilithium  accelerator  onto Field  Programmable  Gate  Array  (FPGA) platforms. 3."
    ]
  },
  {
    "question": "What is the plan to utilize the MiniNDN Framework?",
    "answer": "provides a lightweight simulation environment for NDN \nNetwork",
    "supporting_passages": [
      "Integrate the Dilithium  accelerator with the NDN Network. Hence, the plan is to utilize the \nMiniNDN Framework which provides a lightweight simulation environment for NDN \nNetwork. 4. Perform  testing  to ensure  the algorithms  are implemented  according  to the standard. 6  2. Background  and Literature  Review  \n \n2.1 Background  \nThe rapid  evolution  of internet  technologies has  prompted  a paradigm  shift from  traditional, location - \nbased communication models to data -centric architecture such as Named Data Networking (NDN). NDN  redefines how  content is  requested  and delivered  over the internet by  focusing  on the data itself \nrather  than its location. This emerging  approach  enhances  efficiency  and security,  positioning  NDN  as \na potential  foundation  for the future  of the internet. However,  as technology  progresses,  new challenges \narise, particularly in the realm of security. The rise of quantum computing presents a significant threat to current cryptographic systems, \nespecially  widely  used algorithms like  RSA  and ECC, whi ch are susceptible  to quantum  attacks. This \nthreat has led to the development of post -quantum cryptography, a new stream of cryptography that \ncan withstand the computational power of quantum computers."
    ]
  },
  {
    "question": "What is the plan to use the MiniNDN Framework?",
    "answer": "a lightweight simulation environment for NDN \nNetwork",
    "supporting_passages": [
      "Integrate the Dilithium  accelerator with the NDN Network. Hence, the plan is to utilize the \nMiniNDN Framework which provides a lightweight simulation environment for NDN \nNetwork. 4. Perform  testing  to ensure  the algorithms  are implemented  according  to the standard. 6  2. Background  and Literature  Review  \n \n2.1 Background  \nThe rapid  evolution  of internet  technologies has  prompted  a paradigm  shift from  traditional, location - \nbased communication models to data -centric architecture such as Named Data Networking (NDN). NDN  redefines how  content is  requested  and delivered  over the internet by  focusing  on the data itself \nrather  than its location. This emerging  approach  enhances  efficiency  and security,  positioning  NDN  as \na potential  foundation  for the future  of the internet. However,  as technology  progresses,  new challenges \narise, particularly in the realm of security. The rise of quantum computing presents a significant threat to current cryptographic systems, \nespecially  widely  used algorithms like  RSA  and ECC, whi ch are susceptible  to quantum  attacks. This \nthreat has led to the development of post -quantum cryptography, a new stream of cryptography that \ncan withstand the computational power of quantum computers."
    ]
  },
  {
    "question": "What cryptographic algorithms have emerged as promising candidates for secure communication in a post -quantum world?",
    "answer": "Dilithium",
    "supporting_passages": [
      "Among these, lattice -based \ncryptographic algorithms, s uch as Dilithium, have emerged as promising candidates for secure \ncommunication in a post -quantum world. The project ATHESTIA is grounded in the integration of post -quantum cryptographic techniques \nwithin NDN to secure data communication against future quantum threats. The project has evolved \nfrom early explorations into NDN\u2019s potential for secure networking,  now focused on incorporating \nDilithium to provide quantum -safe authentication and integrity in NDN environments. The current \nstate of the project involves experimenting with the integration of  Dilithium into NDN and assessing \nthe feasibility of this solut ion through MiniNDN emulator and Dilithium accelerator to ensure real - \nworld applicability. This project aims to address the imminent security vulnerabilities posed by quantum computing, \nmaking  NDN  more  resilient  and future -proof. Through  ATHESTIA,  we aim to offer  a secure  solution, \npaving the way for post -quantum internet communication. 7  2.2 Similar  Applications  \nWhile Named Data Networking (NDN) represents a forward -thinking architecture for internet \ncommunications, many of the security solutions currently  deployed in NDN and similar systems are  \nbased on traditional cryptographic techniques."
    ]
  },
  {
    "question": "What cryptographic algorithms are promising candidates for secure communication in a post -quantum world?",
    "answer": "Dilithium",
    "supporting_passages": [
      "Among these, lattice -based \ncryptographic algorithms, s uch as Dilithium, have emerged as promising candidates for secure \ncommunication in a post -quantum world. The project ATHESTIA is grounded in the integration of post -quantum cryptographic techniques \nwithin NDN to secure data communication against future quantum threats. The project has evolved \nfrom early explorations into NDN\u2019s potential for secure networking,  now focused on incorporating \nDilithium to provide quantum -safe authentication and integrity in NDN environments. The current \nstate of the project involves experimenting with the integration of  Dilithium into NDN and assessing \nthe feasibility of this solut ion through MiniNDN emulator and Dilithium accelerator to ensure real - \nworld applicability. This project aims to address the imminent security vulnerabilities posed by quantum computing, \nmaking  NDN  more  resilient  and future -proof. Through  ATHESTIA,  we aim to offer  a secure  solution, \npaving the way for post -quantum internet communication. 7  2.2 Similar  Applications  \nWhile Named Data Networking (NDN) represents a forward -thinking architecture for internet \ncommunications, many of the security solutions currently  deployed in NDN and similar systems are  \nbased on traditional cryptographic techniques."
    ]
  },
  {
    "question": "What is one of the most common security solutions in NDN?",
    "answer": "RSA -based digital signatures",
    "supporting_passages": [
      "These approaches are effective in classical computing  \nenvironments but exhibit vulnerabilities when faced with the computational capabilities of quantum \ncomputers. Seve ral similar  applications  have emerged,  leveraging  a range  of cryptographic  strategies, \ntechnologies, and methodologies. Key existing solutions [2] include:  \n2.2.1. RSA -Based  Authentication  in NDN  \nOne of the most common security implementations in NDN is RSA -based digital signatures for \nauthentication and data integrity. RSA's primary strength lies in its robustness against traditional \ncryptographic attacks. However, its reliance on the difficulty of factoring large numbers renders it \nvulnerable to quantum attacks. Specifically, Shor\u2019s algorithm can break RSA encryption, making it \ninadequate for post -quantum security requirements. This limitation is a key reason why RSA -based \nauthentication systems are under scrutiny as quantum threats become more imminent. 2.2.2 ECC  Integration  in Network  Security  \nAnother widely implemented technology is Elliptic Curve Cryptography (ECC), used across many \nNDN applications and broader network security systems. ECC offers stronger security with shorter \nkey lengths  compared  to RSA,  makin g it more  efficient  in terms  of computation  and bandwidth  usage. However, like  RSA, ECC  is also vulnerable  to quantum  attacks."
    ]
  },
  {
    "question": "What is one of the most common security solutions for NDN?",
    "answer": "RSA -based digital signatures",
    "supporting_passages": [
      "These approaches are effective in classical computing  \nenvironments but exhibit vulnerabilities when faced with the computational capabilities of quantum \ncomputers. Seve ral similar  applications  have emerged,  leveraging  a range  of cryptographic  strategies, \ntechnologies, and methodologies. Key existing solutions [2] include:  \n2.2.1. RSA -Based  Authentication  in NDN  \nOne of the most common security implementations in NDN is RSA -based digital signatures for \nauthentication and data integrity. RSA's primary strength lies in its robustness against traditional \ncryptographic attacks. However, its reliance on the difficulty of factoring large numbers renders it \nvulnerable to quantum attacks. Specifically, Shor\u2019s algorithm can break RSA encryption, making it \ninadequate for post -quantum security requirements. This limitation is a key reason why RSA -based \nauthentication systems are under scrutiny as quantum threats become more imminent. 2.2.2 ECC  Integration  in Network  Security  \nAnother widely implemented technology is Elliptic Curve Cryptography (ECC), used across many \nNDN applications and broader network security systems. ECC offers stronger security with shorter \nkey lengths  compared  to RSA,  makin g it more  efficient  in terms  of computation  and bandwidth  usage. However, like  RSA, ECC  is also vulnerable  to quantum  attacks."
    ]
  },
  {
    "question": "What is Shor's algorithm?",
    "answer": "Quantum  algorithms",
    "supporting_passages": [
      "Quantum  algorithms, such  as Shor\u2019s, \ncan efficiently  solve mathematical  problems  underpinning  ECC,  meaning it cannot  provide long-term \nsecurity in the presence of quantum computing capabilities. 2.2.3.  AES  in NDN  Data  Encryption  \nThe Advanced  Encryption  Standard  (AES)  is extensively  used for encrypting  data across  various  layers \nof network protocols, including NDN. AES has shown resilie nce against certain types of quantum \nattacks, specifically Grover\u2019s algorithm, which reduces the effective key length by half. However, to \nremain secure in a post -quantum world, AES requires significantly larger key lengths (e.g., shifting \nfrom 128 -bit key s to 256 -bit keys), which could negatively impact performance, particularly in \nresource -constrained environments like IoT and lightweight NDN nodes  \n \n8   \nTable  2.1 Comparison  Table  of Existing  Solutions  \n \nTechnology  / \nApplication  Purpose  Strength  Limitations  \nRSA -Based \nAuthentication  in \nNDN  Provides  authentication \nand data integrity via \ndigital signatures. - Well -established \nwith widespread \nadoption. - Strong  protection  in \nclassical \nenvironments. - Vulnerable  to quantum \nattacks (Shor\u2019s \nalgorithm). - Requires  large  key \nsizes, impacting \nperformance. ECC  Integration  in \nNetwork Security  Secures network \ncommunication  with \nshorter key lengths. - Provides higher \nsecurity  with smaller \nkeys than RSA. - More efficient in \nterms of \ncomputational  cost."
    ]
  },
  {
    "question": "What is Shor's algorithm used for?",
    "answer": "solve mathematical  problems",
    "supporting_passages": [
      "Quantum  algorithms, such  as Shor\u2019s, \ncan efficiently  solve mathematical  problems  underpinning  ECC,  meaning it cannot  provide long-term \nsecurity in the presence of quantum computing capabilities. 2.2.3.  AES  in NDN  Data  Encryption  \nThe Advanced  Encryption  Standard  (AES)  is extensively  used for encrypting  data across  various  layers \nof network protocols, including NDN. AES has shown resilie nce against certain types of quantum \nattacks, specifically Grover\u2019s algorithm, which reduces the effective key length by half. However, to \nremain secure in a post -quantum world, AES requires significantly larger key lengths (e.g., shifting \nfrom 128 -bit key s to 256 -bit keys), which could negatively impact performance, particularly in \nresource -constrained environments like IoT and lightweight NDN nodes  \n \n8   \nTable  2.1 Comparison  Table  of Existing  Solutions  \n \nTechnology  / \nApplication  Purpose  Strength  Limitations  \nRSA -Based \nAuthentication  in \nNDN  Provides  authentication \nand data integrity via \ndigital signatures. - Well -established \nwith widespread \nadoption. - Strong  protection  in \nclassical \nenvironments. - Vulnerable  to quantum \nattacks (Shor\u2019s \nalgorithm). - Requires  large  key \nsizes, impacting \nperformance. ECC  Integration  in \nNetwork Security  Secures network \ncommunication  with \nshorter key lengths. - Provides higher \nsecurity  with smaller \nkeys than RSA. - More efficient in \nterms of \ncomputational  cost."
    ]
  },
  {
    "question": "What are the three Dilithium Algorithms?",
    "answer": "Key Generation",
    "supporting_passages": [
      "- Susceptible  to quantum \nattacks (Shor's \nalgorithm). - Inadequate  for future \npost-quantum  security. AES  in NDN  Data \nEncryption  Encrypts data across \nvarious  layers  in NDN  to \nensure confidentiality. - Resistant  to classical \nattacks. - Partially  resilient  to \nquantum attacks \n(Grover\u2019s  algorithm). - Requires  key length \nscaling for quantum \nresistance, affecting \nperformance. 2.3. Algorithms  \nIn the context of Named Data Networking (NDN) and post -quantum cryptography, Athestia is built \nupon the Dilithium  algorithm, a lattice -based digital signature scheme. Below is a breakdown of \nDilithium  algorithms and a comparison  with other traditional  algorithms used in  similar applications. 2.3.1. Dilithium  Algorithms  \nThe three  Dilithium  algorithms  are as follows:  \n2.3.1.1. Key Generation:  \n\u25cb The Dilithium  algorithm  generates  a pair of keys:  a private  key for signing  and a public \nkey for verification. \u25cb This key generation process relies on lattice -based mathematical problems, making it \nresistant to quantum attacks. 9  2.3.1.2. Signature  \n\u25cb The signing  process  uses the private  key to create  a digital  signature  for a given \nmessage. The signature  ensures  the message\u2019s  authenticity  and integrity  in the network. 2.3.1.3."
    ]
  },
  {
    "question": "What is the main feature of the Dilithium algorithm?",
    "answer": "generates  a pair of keys",
    "supporting_passages": [
      "- Susceptible  to quantum \nattacks (Shor's \nalgorithm). - Inadequate  for future \npost-quantum  security. AES  in NDN  Data \nEncryption  Encrypts data across \nvarious  layers  in NDN  to \nensure confidentiality. - Resistant  to classical \nattacks. - Partially  resilient  to \nquantum attacks \n(Grover\u2019s  algorithm). - Requires  key length \nscaling for quantum \nresistance, affecting \nperformance. 2.3. Algorithms  \nIn the context of Named Data Networking (NDN) and post -quantum cryptography, Athestia is built \nupon the Dilithium  algorithm, a lattice -based digital signature scheme. Below is a breakdown of \nDilithium  algorithms and a comparison  with other traditional  algorithms used in  similar applications. 2.3.1. Dilithium  Algorithms  \nThe three  Dilithium  algorithms  are as follows:  \n2.3.1.1. Key Generation:  \n\u25cb The Dilithium  algorithm  generates  a pair of keys:  a private  key for signing  and a public \nkey for verification. \u25cb This key generation process relies on lattice -based mathematical problems, making it \nresistant to quantum attacks. 9  2.3.1.2. Signature  \n\u25cb The signing  process  uses the private  key to create  a digital  signature  for a given \nmessage. The signature  ensures  the message\u2019s  authenticity  and integrity  in the network. 2.3.1.3."
    ]
  },
  {
    "question": "What is the main benefit of using Dilithium for Athestia?",
    "answer": "Efficiency : Dilithium  offers a good balance between performance and security",
    "supporting_passages": [
      "Verification  \n\u25cb The public  key is used to verify  the digital  signature,  ensuring  that the message  has not \nbeen altered and was signed by the legitimate party. 2.3.2. Why  Choose  Dilithium  for Athestia? \u25cf Quantum  Resistance : Unlike  traditional  cryptographic  schemes  like RSA  and ECC,  Dilithium \nis built on lattice -based  cryptography,  which  is resistant  to quantum  algorithms  such as Shor's. This makes it highly suitable for future proofing against quantum threats. \u25cf Efficiency : Dilithium  offers a good balance between performance and security, providing \nefficient key generation, signing, and verification processes, which are crucial in real -time \nNDN applications. \u25cf Standardization : Dilithium  has been chosen as a finalist in the NIST Post -Quantum \nCryptography Standardization process, which indicates its potential to become a widely \nadopted standard for securing data in the quantum computing era. 2.3.3. Algorithms  in Similar  Applications:  \nTo better u nderstand the advantages and motivation behind choosing Dilithium for post -quantum \nsecurity  in Athestia, it is important  to analyze  cryptographic  algorithms  used in  existing  systems  with \nsimilar goals. The following subsections discuss widely adopted class ical algorithms that have been \nimplemented  in Named  Data  Networking  (NDN)  and general  network  security  systems."
    ]
  },
  {
    "question": "What is the main advantage of using Dilithium for Athestia?",
    "answer": "Efficiency : Dilithium  offers a good balance between performance and security",
    "supporting_passages": [
      "Verification  \n\u25cb The public  key is used to verify  the digital  signature,  ensuring  that the message  has not \nbeen altered and was signed by the legitimate party. 2.3.2. Why  Choose  Dilithium  for Athestia? \u25cf Quantum  Resistance : Unlike  traditional  cryptographic  schemes  like RSA  and ECC,  Dilithium \nis built on lattice -based  cryptography,  which  is resistant  to quantum  algorithms  such as Shor's. This makes it highly suitable for future proofing against quantum threats. \u25cf Efficiency : Dilithium  offers a good balance between performance and security, providing \nefficient key generation, signing, and verification processes, which are crucial in real -time \nNDN applications. \u25cf Standardization : Dilithium  has been chosen as a finalist in the NIST Post -Quantum \nCryptography Standardization process, which indicates its potential to become a widely \nadopted standard for securing data in the quantum computing era. 2.3.3. Algorithms  in Similar  Applications:  \nTo better u nderstand the advantages and motivation behind choosing Dilithium for post -quantum \nsecurity  in Athestia, it is important  to analyze  cryptographic  algorithms  used in  existing  systems  with \nsimilar goals. The following subsections discuss widely adopted class ical algorithms that have been \nimplemented  in Named  Data  Networking  (NDN)  and general  network  security  systems."
    ]
  },
  {
    "question": "What is the main reason for use of ECC?",
    "answer": "smaller key sizes and faster \ncomputat ions",
    "supporting_passages": [
      "These  include \nRSA, ECC, and AES, each of which offers different security properties and performance \ncharacteristics but faces limitations in a q uantum computing context. We examine how these \nalgorithms  operate,  their common  use cases, and  why they may fall short  when  facing  future  quantum \nthreats. 2.3.3.1. RSA -Based  Authentication  in NDN:  \n\u25cf Key Generation : RSA  generates  two large  prime  numbers  to create  public  and private  keys. \u25cf Signing : The private  key is used to sign  data for authentication. \u25cf Verification:  The public key  verifies  the authenticity  of the signed  data \n \n10  \u25cf Reason  for Use: RSA  has been  widely  adopted  due to its strength  in classical  environments. However, it is vulnerable to quantum  attacks, as  Shor\u2019s algorithm can efficiently solve the \nunderlying mathematical problems. 2.3.3.2. ECC  Integration  in Network  Security:  \n\u25cf Key Generation : ECC  generates  keys based  on elliptic  curve  equations,  providing \nstronger security with shorter key lengths compared to RSA. \u25cf Signing : ECC  uses the private  key to sign messages. \u25cf Verification : The public  key is used to verify  the signature. \u25cf Reason for Use : ECC is more efficient than RSA due to smaller key sizes and faster \ncomputat ions."
    ]
  },
  {
    "question": "What is the main reason for using ECC?",
    "answer": "smaller key sizes and faster \ncomputat ions",
    "supporting_passages": [
      "These  include \nRSA, ECC, and AES, each of which offers different security properties and performance \ncharacteristics but faces limitations in a q uantum computing context. We examine how these \nalgorithms  operate,  their common  use cases, and  why they may fall short  when  facing  future  quantum \nthreats. 2.3.3.1. RSA -Based  Authentication  in NDN:  \n\u25cf Key Generation : RSA  generates  two large  prime  numbers  to create  public  and private  keys. \u25cf Signing : The private  key is used to sign  data for authentication. \u25cf Verification:  The public key  verifies  the authenticity  of the signed  data \n \n10  \u25cf Reason  for Use: RSA  has been  widely  adopted  due to its strength  in classical  environments. However, it is vulnerable to quantum  attacks, as  Shor\u2019s algorithm can efficiently solve the \nunderlying mathematical problems. 2.3.3.2. ECC  Integration  in Network  Security:  \n\u25cf Key Generation : ECC  generates  keys based  on elliptic  curve  equations,  providing \nstronger security with shorter key lengths compared to RSA. \u25cf Signing : ECC  uses the private  key to sign messages. \u25cf Verification : The public  key is used to verify  the signature. \u25cf Reason for Use : ECC is more efficient than RSA due to smaller key sizes and faster \ncomputat ions."
    ]
  },
  {
    "question": "What is the purpose of AES in NDN Data Encryption?",
    "answer": "encrypts  data using  the secret  key, ensuring  confidentiality",
    "supporting_passages": [
      "However, it still falls short in  post-quantum  security, as it is vulnerable \nto quantum attacks. 2.3.3.3.  AES in  NDN Data  Encryption:  \n\u25cf Key Generation : AES does not rely on public/private key pairs but uses symmetric \nencryption with a secret key. \u25cf Encryption : AES  encrypts  data using  the secret  key, ensuring  confidentiality. \u25cf Decryption : The same  secret  key decrypts  the data at the receiving end. \u25cf Reason  for Use:  AES  is widely  used due to its resilience  to classical  attacks  and partial \nresistance to quantum attacks (Grover\u2019s algorithm). However, quantum resistance \nrequires significantly larger key sizes, which can impact performance. 11   \n3. Aim and Statement  of Problem  \n \nThe aim  of this project is to develop a secure authentication mechanism  for Named Data Networking \n(NDN) by integrating the Dilithium post -quantum cryptographic algorithm. This research focuses on \nmitigating  the vulnerabilities  of NDN  to quantum -based cryptographic attacks,  ensuring its  resilience \nagain st future quantum threats. To achieve this, we will modify the NDN self -certification process \nusing Dilithium, leveraging its lattice -based cryptography  to enhance data  security."
    ]
  },
  {
    "question": "What does AES fall short of in post-quantum security?",
    "answer": "it is vulnerable \nto quantum attacks",
    "supporting_passages": [
      "However, it still falls short in  post-quantum  security, as it is vulnerable \nto quantum attacks. 2.3.3.3.  AES in  NDN Data  Encryption:  \n\u25cf Key Generation : AES does not rely on public/private key pairs but uses symmetric \nencryption with a secret key. \u25cf Encryption : AES  encrypts  data using  the secret  key, ensuring  confidentiality. \u25cf Decryption : The same  secret  key decrypts  the data at the receiving end. \u25cf Reason  for Use:  AES  is widely  used due to its resilience  to classical  attacks  and partial \nresistance to quantum attacks (Grover\u2019s algorithm). However, quantum resistance \nrequires significantly larger key sizes, which can impact performance. 11   \n3. Aim and Statement  of Problem  \n \nThe aim  of this project is to develop a secure authentication mechanism  for Named Data Networking \n(NDN) by integrating the Dilithium post -quantum cryptographic algorithm. This research focuses on \nmitigating  the vulnerabilities  of NDN  to quantum -based cryptographic attacks,  ensuring its  resilience \nagain st future quantum threats. To achieve this, we will modify the NDN self -certification process \nusing Dilithium, leveraging its lattice -based cryptography  to enhance data  security."
    ]
  },
  {
    "question": "What does the project aim to improve performance efficiency by utilizing Dilithium as an accelerator to reduce the time required for signing plain data?",
    "answer": "practical scalability in real -world systems",
    "supporting_passages": [
      "Additionally, the \nproject aims to improve performance efficiency  by utilizing  Dilithium  as an  accelerator  to reduce  the \ntime required for signing plain data, thus ensuring practical scalability in real -world systems. 3.1. Statement  of the Problem  \nIn today\u2019s rapidly evolving technological landscape, securing digital communication is bec oming \nincreasingly  complex, particularly  with the emergence of  quantum  computing. Current cryptographic \nsystems,  which  have  reliably  protected  sensitive  data for decades,  are now under  threat  due to quantum \nalgorithms capable of  breaking their core mathematical  foundations. In  addition  to this cryptographic \nchallenge, modern communication models like Named Data Networking (NDN) introduce unique \nsecurity considerations, such as content -based authentication and real -time data distribution. This projec t addresses two critical problems: the looming vulnerability of classical cryptographic \nalgorithms  to quantum  attacks,  and the need to maintain  efficient and  secure  data exchange within  the \nNDN paradigm. The following subsections elaborate on these two pro blem areas and how the \nintegration of the Dilithium post -quantum algorithm aims to provide a sustainable and forward - \ncompatible solution. 3.1.1. Cryptographic  Vulnerabilities  to Quantum  Computing  \nWith the advent of quantum computing, traditional cryptographic algorithms such as RSA and ECC \nare no longer sufficient to ensure  secure  communication."
    ]
  },
  {
    "question": "What does the project aim to improve performance efficiency by utilizing Dilithium as an accelerator?",
    "answer": "to reduce  the \ntime required for signing plain data",
    "supporting_passages": [
      "Additionally, the \nproject aims to improve performance efficiency  by utilizing  Dilithium  as an  accelerator  to reduce  the \ntime required for signing plain data, thus ensuring practical scalability in real -world systems. 3.1. Statement  of the Problem  \nIn today\u2019s rapidly evolving technological landscape, securing digital communication is bec oming \nincreasingly  complex, particularly  with the emergence of  quantum  computing. Current cryptographic \nsystems,  which  have  reliably  protected  sensitive  data for decades,  are now under  threat  due to quantum \nalgorithms capable of  breaking their core mathematical  foundations. In  addition  to this cryptographic \nchallenge, modern communication models like Named Data Networking (NDN) introduce unique \nsecurity considerations, such as content -based authentication and real -time data distribution. This projec t addresses two critical problems: the looming vulnerability of classical cryptographic \nalgorithms  to quantum  attacks,  and the need to maintain  efficient and  secure  data exchange within  the \nNDN paradigm. The following subsections elaborate on these two pro blem areas and how the \nintegration of the Dilithium post -quantum algorithm aims to provide a sustainable and forward - \ncompatible solution. 3.1.1. Cryptographic  Vulnerabilities  to Quantum  Computing  \nWith the advent of quantum computing, traditional cryptographic algorithms such as RSA and ECC \nare no longer sufficient to ensure  secure  communication."
    ]
  },
  {
    "question": "What is the Dilithium algorithm?",
    "answer": "a lattice -based digital signature algorithm",
    "supporting_passages": [
      "Quantum  algorithms, like  Shor\u2019s  algorithm, \nhave the potential to break these cryptographic systems, exposing sensitive data to malicious actors. The challenge  is to adopt post-quantum  cryptographic  algorithms  that can withstand  these  new threats. The problem lies in identifying an  efficient and secure solution  that can  replace these legacy systems \nwithout compromising performance. This project addresses this by implement ing the Dilithium \nalgorithm, a lattice -based digital signature algorithm recognized for its quantum resistance. 12  3.1.2. Challenges  in Secure  Data  Distribution  with  Named  Data Networking \n(NDN)  \n \nIn addition to cryptographic challenges, the project also tackles issues related to secure data \ndistribution  in modern  communication  models  like Named  Data  Networking  (NDN). NDN  focuses  on \nsecuring data rather than endpoints, which presents a unique opportunity to integrate post -quantum \ncryptographic  methods like Dilithium. However, this integration introduces challenges, such as \nensuring  that cryptographic  operations,  like signing  and verification,  are efficiently  performed  without \nslowing down the real -time data distribution NDN is designed for. The  Dilithium algorithm, \nimplemented  in this project,  ensures  that data authenticity  and integrity  are maintained  within  the NDN \nframework, providing a quantum -resistant solution that supports secure communication in future \nnetworking paradigms. 3.2."
    ]
  },
  {
    "question": "What does the Dilithium algorithm do?",
    "answer": "ensures  that data authenticity  and integrity  are maintained",
    "supporting_passages": [
      "Quantum  algorithms, like  Shor\u2019s  algorithm, \nhave the potential to break these cryptographic systems, exposing sensitive data to malicious actors. The challenge  is to adopt post-quantum  cryptographic  algorithms  that can withstand  these  new threats. The problem lies in identifying an  efficient and secure solution  that can  replace these legacy systems \nwithout compromising performance. This project addresses this by implement ing the Dilithium \nalgorithm, a lattice -based digital signature algorithm recognized for its quantum resistance. 12  3.1.2. Challenges  in Secure  Data  Distribution  with  Named  Data Networking \n(NDN)  \n \nIn addition to cryptographic challenges, the project also tackles issues related to secure data \ndistribution  in modern  communication  models  like Named  Data  Networking  (NDN). NDN  focuses  on \nsecuring data rather than endpoints, which presents a unique opportunity to integrate post -quantum \ncryptographic  methods like Dilithium. However, this integration introduces challenges, such as \nensuring  that cryptographic  operations,  like signing  and verification,  are efficiently  performed  without \nslowing down the real -time data distribution NDN is designed for. The  Dilithium algorithm, \nimplemented  in this project,  ensures  that data authenticity  and integrity  are maintained  within  the NDN \nframework, providing a quantum -resistant solution that supports secure communication in future \nnetworking paradigms. 3.2."
    ]
  },
  {
    "question": "What are the main stakeholders affected by the project?",
    "answer": "Researchers  and Developers",
    "supporting_passages": [
      "Scope  and Stakeholders  \nThe scope of the project is focused on addressing both the security and performance aspects of \nintegrating Dilithium into NDN. The main stakeholders affected include:  \n3.2.1. Researchers  and Developers  \nResearchers working on network security and post -quantum cryptography are at the forefront of \ndesigning secure and efficient communication systems. They require practical, deployable \ncryptographic solutions capable of  resisting attacks from  quantum  computers while maintaining high \nthroughput and efficien cy in real -world systems. With the growing push for NIST -approved post - \nquantum  algorithms, researchers need  to explore  methods  of optimizing  algorithms like  Dilithium  for \nsecurity. This project addresses these needs by combining Dilithium\u2019s lattice -based cryptographic \nsecurity, offering a solution that is both quantum -resistant and performant for NDN systems. 3.2.2. End Users  \nThe ultimate  beneficiaries  of this project are  end users who rely  on secure,  and efficient,  networks  for \naccessing content and data. Quantum computing threatens the integrity and security of current \ncommunication systems, making the transition to post -quantum  security crucial for protecting users\u2019 \nsensitive  data in the future. This project  ensures  that the NDN  architecture  remains  secur e and capable \nof safeguarding data against quantum adversaries."
    ]
  },
  {
    "question": "What are the main stakeholders affected by this project?",
    "answer": "Researchers  and Developers",
    "supporting_passages": [
      "Scope  and Stakeholders  \nThe scope of the project is focused on addressing both the security and performance aspects of \nintegrating Dilithium into NDN. The main stakeholders affected include:  \n3.2.1. Researchers  and Developers  \nResearchers working on network security and post -quantum cryptography are at the forefront of \ndesigning secure and efficient communication systems. They require practical, deployable \ncryptographic solutions capable of  resisting attacks from  quantum  computers while maintaining high \nthroughput and efficien cy in real -world systems. With the growing push for NIST -approved post - \nquantum  algorithms, researchers need  to explore  methods  of optimizing  algorithms like  Dilithium  for \nsecurity. This project addresses these needs by combining Dilithium\u2019s lattice -based cryptographic \nsecurity, offering a solution that is both quantum -resistant and performant for NDN systems. 3.2.2. End Users  \nThe ultimate  beneficiaries  of this project are  end users who rely  on secure,  and efficient,  networks  for \naccessing content and data. Quantum computing threatens the integrity and security of current \ncommunication systems, making the transition to post -quantum  security crucial for protecting users\u2019 \nsensitive  data in the future. This project  ensures  that the NDN  architecture  remains  secur e and capable \nof safeguarding data against quantum adversaries."
    ]
  },
  {
    "question": "What does the integration of Dilithium for Secure Authentication do?",
    "answer": "ensuring  the \nsystem remains robust against quantum threats",
    "supporting_passages": [
      "13  3.3 Approach  to Tackling  the Problem  \nTo address the dual  challenges of  cryptographic vulnerability in the quantum era and the demands of \nsecure  data distribution  in NDN,  a strategic  and technically  sound  approach  is required. The  proposed  \nsolution  must  not only provide  robust  security  but also align  with the architectural  principles  of Named \nData Networking \u2014particularly its focus on content authenticity and self -certification. This projec t adopts  a hardware -accelerated,  post-quantum  cryptographic  framework  by integrating  the \nDilithium  algorithm into the NDN infrastructure. The following subsection explains how this \nintegration is designed to enhance the self -certification mechanism of NDN and deliver a scalable, \nquantum -resistant authentication solution. 3.3.1. Integration  of Dilithium  for Secure  Authentication  \nThe primary objective of the project is to enhance the self -certification process of NDN by \nincorporating the Dilithium algorithm. Dilithium is a lattice -based digital signature algorithm \nrecognized for its quantum resistance. By replac ing traditional cryptographic schemes like RSA and \nECC with Dilithium, the system  will be able to withstand potential  quantum  attacks. This integration \nensures  that data  authenticity  and integrity  are maintained in  the NDN  architecture  while  ensuring  the \nsystem remains robust against quantum threats. 14   \n4."
    ]
  },
  {
    "question": "What is the main objective of the project?",
    "answer": "to enhance the self -certification process of NDN",
    "supporting_passages": [
      "13  3.3 Approach  to Tackling  the Problem  \nTo address the dual  challenges of  cryptographic vulnerability in the quantum era and the demands of \nsecure  data distribution  in NDN,  a strategic  and technically  sound  approach  is required. The  proposed  \nsolution  must  not only provide  robust  security  but also align  with the architectural  principles  of Named \nData Networking \u2014particularly its focus on content authenticity and self -certification. This projec t adopts  a hardware -accelerated,  post-quantum  cryptographic  framework  by integrating  the \nDilithium  algorithm into the NDN infrastructure. The following subsection explains how this \nintegration is designed to enhance the self -certification mechanism of NDN and deliver a scalable, \nquantum -resistant authentication solution. 3.3.1. Integration  of Dilithium  for Secure  Authentication  \nThe primary objective of the project is to enhance the self -certification process of NDN by \nincorporating the Dilithium algorithm. Dilithium is a lattice -based digital signature algorithm \nrecognized for its quantum resistance. By replac ing traditional cryptographic schemes like RSA and \nECC with Dilithium, the system  will be able to withstand potential  quantum  attacks. This integration \nensures  that data  authenticity  and integrity  are maintained in  the NDN  architecture  while  ensuring  the \nsystem remains robust against quantum threats. 14   \n4."
    ]
  },
  {
    "question": "What were the first three fact-finding techniques used to gather requirements and ensure the most efficient and secure design for the Dilithium accelerator?",
    "answer": "\n1. Literature Review",
    "supporting_passages": [
      "Hardware,  Software  analysis  and requirements  \n \n4.1. Fact-Finding  Techniques  \nIn the initial  phase  of the project,  several  fact-finding  techniques  were  employed  to gather  requirements \nand ensure  the most  efficient  and secure  design  for the Dilithium  accelerator. These  techniques include:  \n1. Literature Review : A thorough study of post -quantum cryptography and the Dilithium \nalgorithm was conducted by reviewing research papers, s tandards from NIST, and technical \ndocumentation. This helped us to understand the security requirements and performance \nexpectations for the project. 2. Discussions  with  cryptography  experts : Discussions  were  held with cryptography  experts  on \npqc-forum groups  to understand the practical challenges of implementing lattice -based \ncryptographic algorithms. 4.2. Hardware  Analysis  and Requirements  \nFor the hardware  platform,  the project  required  specialized  resources  capable  of handling  the \ncomputational complexity of the Dilithium algorithm, including:  \n4.2.1. Xilinx  Zynq -7000  SoC \n\u25cb Pros : Combines  an ARM  processor  with programmable  logic,  providing  flexibility  for \nboth software  and hardware  tasks. Its high-performance  capabilities  make  it suitable  for \nreal-time applications. \u25cb Cons : Higher  power  consumption  and cost compared  to smaller  FPGAs. 4.2.2. Intel  (Altera)  Cyclone  V FPGA  \n\u25cb Pros : Low power  consumption  and relatively  lower  cost. Ideal  for prototyping \ncryptographic accelerators."
    ]
  },
  {
    "question": "What were the first three fact-finding techniques used to gather requirements and ensure the most efficient and secure design of the Dilithium accelerator?",
    "answer": "\n1. Literature Review",
    "supporting_passages": [
      "Hardware,  Software  analysis  and requirements  \n \n4.1. Fact-Finding  Techniques  \nIn the initial  phase  of the project,  several  fact-finding  techniques  were  employed  to gather  requirements \nand ensure  the most  efficient  and secure  design  for the Dilithium  accelerator. These  techniques include:  \n1. Literature Review : A thorough study of post -quantum cryptography and the Dilithium \nalgorithm was conducted by reviewing research papers, s tandards from NIST, and technical \ndocumentation. This helped us to understand the security requirements and performance \nexpectations for the project. 2. Discussions  with  cryptography  experts : Discussions  were  held with cryptography  experts  on \npqc-forum groups  to understand the practical challenges of implementing lattice -based \ncryptographic algorithms. 4.2. Hardware  Analysis  and Requirements  \nFor the hardware  platform,  the project  required  specialized  resources  capable  of handling  the \ncomputational complexity of the Dilithium algorithm, including:  \n4.2.1. Xilinx  Zynq -7000  SoC \n\u25cb Pros : Combines  an ARM  processor  with programmable  logic,  providing  flexibility  for \nboth software  and hardware  tasks. Its high-performance  capabilities  make  it suitable  for \nreal-time applications. \u25cb Cons : Higher  power  consumption  and cost compared  to smaller  FPGAs. 4.2.2. Intel  (Altera)  Cyclone  V FPGA  \n\u25cb Pros : Low power  consumption  and relatively  lower  cost. Ideal  for prototyping \ncryptographic accelerators."
    ]
  },
  {
    "question": "What were the pros and cons of the Arty -7 FPGA?",
    "answer": "Strikes a balance between performance, power consumption, and cost",
    "supporting_passages": [
      "\u25cb Cons : Limited performance for high -throughput applications, making it less ideal for \nreal-time secure communication systems. 4.2.3. Arty -7 FPGA  (Chosen)  \n\u25cb Pros : Strikes a balance between performance, power consumption, and cost. It offers \nenough computational power to handle Dilithium's pol ynomial multiplication   \n \n \n15  operations while remaining energy -efficient, making it ideal for cryptographic \napplications. \u25cb Why Chosen : The Arty -7 provides excellent flexibility for porting the Dilithium \nalgorithm  and supports  the required  performance  for key generation,  signature  creation, \nand verification at a lower power footprint compared to Zynq -7000. The final decision to use the Arty -7 FPGA was based on its balance of cost,  power efficiency,  and \nperformance, and due to the team's familiarity and proficie ncy with Arty -7 FPGA. 4.3. Software  Analysis  and Requirements  \nSeveral  software  technologies  were  evaluated  to determine  the best combination  for the front -end \ninterface, back -end logic, and middle layer:  \n1. Front -End: \n\u25cb Python was chosen for developing the initial implementation of the Dilithium \nalgorithm. Python\u2019s extensive libraries, such as PyCryptodome, made it easier to use \nshake algorithm libraries. 2. Back -End: \n\u25cb SystemVerilog  was selected  for implementing  hardware  logic on the FPGA."
    ]
  },
  {
    "question": "What was the Pros of the Arty -7 FPGA?",
    "answer": "Strikes a balance between performance, power consumption, and cost",
    "supporting_passages": [
      "\u25cb Cons : Limited performance for high -throughput applications, making it less ideal for \nreal-time secure communication systems. 4.2.3. Arty -7 FPGA  (Chosen)  \n\u25cb Pros : Strikes a balance between performance, power consumption, and cost. It offers \nenough computational power to handle Dilithium's pol ynomial multiplication   \n \n \n15  operations while remaining energy -efficient, making it ideal for cryptographic \napplications. \u25cb Why Chosen : The Arty -7 provides excellent flexibility for porting the Dilithium \nalgorithm  and supports  the required  performance  for key generation,  signature  creation, \nand verification at a lower power footprint compared to Zynq -7000. The final decision to use the Arty -7 FPGA was based on its balance of cost,  power efficiency,  and \nperformance, and due to the team's familiarity and proficie ncy with Arty -7 FPGA. 4.3. Software  Analysis  and Requirements  \nSeveral  software  technologies  were  evaluated  to determine  the best combination  for the front -end \ninterface, back -end logic, and middle layer:  \n1. Front -End: \n\u25cb Python was chosen for developing the initial implementation of the Dilithium \nalgorithm. Python\u2019s extensive libraries, such as PyCryptodome, made it easier to use \nshake algorithm libraries. 2. Back -End: \n\u25cb SystemVerilog  was selected  for implementing  hardware  logic on the FPGA."
    ]
  },
  {
    "question": "What is the name of the protocol used to communicate between the miniNDN simulator and the FPGA hardware?",
    "answer": "UART",
    "supporting_passages": [
      "This HDL \nallows for precise control over the low -level operations needed for efficient key \ngeneration, signature creation, and verification. 3. Middle  Layer  (Communication  Protocol) : \n\u25cb The UART protocol was selected as the communication layer between the miniNDN \nsimulator running on the laptop and the FPGA hardware. UART offers reliable and \nstraightforward data transmission between the software and hardware layers. 4. Simulation : \n\u25cb To simulat e the working of Dilithium, we will integrate it with the NDN Network. Hence, the plan is to utilize the MiniNDN Framework which provides a lightweight \nsimulation environment for NDN Network. 4.4. System  Structure  \nThe overall  system  consists  of the following  components:  \n\u25cf Laptop Running miniNDN : The software layer simulates the NDN environment and sends \nmessages to be signed and verified using Dilithium. 16  \u25cf UART Protocol : A communication channel  that links the laptop and the FPGA, transmitting \ndata for cryptographic operations. \u25cf FPGA  (Arty -7): Port the Dilithium  accelerator  onto Field  Programmable  Gate  Array  (FPGA) \nplatforms. \u25cf Dilithium  Accelerator : Designing  of a hardware  accelerator  for the Dilithium  digital  signature \noperations using SystemVerilog, which includes key generation, signature, and verification \nalgorithms."
    ]
  },
  {
    "question": "What is the name of the protocol used to communicate between the miniNDN simulator and the FPGA?",
    "answer": "UART",
    "supporting_passages": [
      "This HDL \nallows for precise control over the low -level operations needed for efficient key \ngeneration, signature creation, and verification. 3. Middle  Layer  (Communication  Protocol) : \n\u25cb The UART protocol was selected as the communication layer between the miniNDN \nsimulator running on the laptop and the FPGA hardware. UART offers reliable and \nstraightforward data transmission between the software and hardware layers. 4. Simulation : \n\u25cb To simulat e the working of Dilithium, we will integrate it with the NDN Network. Hence, the plan is to utilize the MiniNDN Framework which provides a lightweight \nsimulation environment for NDN Network. 4.4. System  Structure  \nThe overall  system  consists  of the following  components:  \n\u25cf Laptop Running miniNDN : The software layer simulates the NDN environment and sends \nmessages to be signed and verified using Dilithium. 16  \u25cf UART Protocol : A communication channel  that links the laptop and the FPGA, transmitting \ndata for cryptographic operations. \u25cf FPGA  (Arty -7): Port the Dilithium  accelerator  onto Field  Programmable  Gate  Array  (FPGA) \nplatforms. \u25cf Dilithium  Accelerator : Designing  of a hardware  accelerator  for the Dilithium  digital  signature \noperations using SystemVerilog, which includes key generation, signature, and verification \nalgorithms."
    ]
  },
  {
    "question": "What is the role of the Control Unit in Athestia 17?",
    "answer": "Directs  the overall  operation  of the accelerator",
    "supporting_passages": [
      "Figure  4.1 System  Diagram  of Athestia  \n\n \n17  Figure  4.1 illustrates  the architecture  and interaction  between  the miniNDN  (Named  Data  Networking) \nframework  and the Dilithium  Accelerator  to ensure  secure  and efficient communication  through  post- \nquantum cryptographic methods. \u25cf miniNDN  Framework:  \na. The NDN framework  is depicted  with Producers, Consumers, and  Routers  that facilitate \nthe exchange of data packets. b. The Certificate Authority  (CA) issues certificates  to secure network  interactions. Data \npackets travel through routers, allowing consumers to retrieve information from \nproducers. \u25cf UART  Protocol:  \na. The Universal  Asynchronous  Receiver -Transmitter  (UART)  protocol  is used to bridge \ncommunication between the miniNDN framework and the Dilithium Accelerator, \nenabling data exchange for cryptographic operations. \u25cf Dilithium  Accelerator:  \na. The Dilithium  Accelerator  performs  critical  cryptographic  operations  such as key \ngeneration, signing, and verification of data packets. i. Decoder:  Decodes  incoming  requests  or data packets  from  the miniNDN  \nframework. ii. Memory  Controller:  Manages  the memory  operations  required  for \ncryptographic key storage and retrieval. iii. Control  Unit:  Directs  the overall  operation  of the accelerator,  coordinating  tasks \nlike key generation, signing, and verifying. \u25cf Cryptographic  Operations:  \na. Key Generation:  Produces  public  and private  keys for  signature  and verification. b."
    ]
  },
  {
    "question": "What is the main function of the miniNDN framework?",
    "answer": "ensure  secure  and efficient communication",
    "supporting_passages": [
      "Figure  4.1 System  Diagram  of Athestia  \n\n \n17  Figure  4.1 illustrates  the architecture  and interaction  between  the miniNDN  (Named  Data  Networking) \nframework  and the Dilithium  Accelerator  to ensure  secure  and efficient communication  through  post- \nquantum cryptographic methods. \u25cf miniNDN  Framework:  \na. The NDN framework  is depicted  with Producers, Consumers, and  Routers  that facilitate \nthe exchange of data packets. b. The Certificate Authority  (CA) issues certificates  to secure network  interactions. Data \npackets travel through routers, allowing consumers to retrieve information from \nproducers. \u25cf UART  Protocol:  \na. The Universal  Asynchronous  Receiver -Transmitter  (UART)  protocol  is used to bridge \ncommunication between the miniNDN framework and the Dilithium Accelerator, \nenabling data exchange for cryptographic operations. \u25cf Dilithium  Accelerator:  \na. The Dilithium  Accelerator  performs  critical  cryptographic  operations  such as key \ngeneration, signing, and verification of data packets. i. Decoder:  Decodes  incoming  requests  or data packets  from  the miniNDN  \nframework. ii. Memory  Controller:  Manages  the memory  operations  required  for \ncryptographic key storage and retrieval. iii. Control  Unit:  Directs  the overall  operation  of the accelerator,  coordinating  tasks \nlike key generation, signing, and verifying. \u25cf Cryptographic  Operations:  \na. Key Generation:  Produces  public  and private  keys for  signature  and verification. b."
    ]
  },
  {
    "question": "What is the purpose of the Athestia system?",
    "answer": "secures data exchange using post -quantum cryptography",
    "supporting_passages": [
      "Signature:  The signature  unit signs  data packets  to guarantee  integrity  and authenticity. c. Verifier:  Verifies  signatures  using  public  keys to ensure  data authenticity  and security. This architecture demonstrates the seamless integration of  the Dilithium post -quantum  cryptographic \naccelerator with the miniNDN framework, ensuring robust security for future network \ncommunications. 18  4.4.1. Actor  Use Case  Diagram  \n \n \nFigure  4.2 Actor  Use Case  Diagram  \nFigure  4.2 presents  a use case diagram  describing  the interac tion between  various  actors  in the Athestia \nsystem, which secures data exchange using post -quantum cryptography, specifically the Dilithium \nalgorithm, and certificates managed by  the Certificate Authority  (CA) within the NDN framework. Actors:  \n1. Consumer:  Requests  data and verifies  the authenticity  and integrity  of data packets. 2. Producer:  Provides  data packets  and ensures  they are signed and certified. 3. Dilithium:  A post-quantum  cryptographic  algorithm  used for key generation,  signing,  and \nsignature verification. 4. Certificate  Authority  (CA):  Responsible for  signing  and certifying  public  keys. 5. NDN  Router:  Forwards  and stores  interest  and data packets  within  the network. 19  Use Case  Breakdown:  \n1. Consumer  Use Cases:  \n\u25cb Generate  interest  packet:  Consumer  generates  a request  for data (interest  packet). \u25cb Receive  data packet:  The consumer  receives  a data packet  from  the producer."
    ]
  },
  {
    "question": "What does the Athestia system do?",
    "answer": "secures data exchange using post -quantum cryptography",
    "supporting_passages": [
      "Signature:  The signature  unit signs  data packets  to guarantee  integrity  and authenticity. c. Verifier:  Verifies  signatures  using  public  keys to ensure  data authenticity  and security. This architecture demonstrates the seamless integration of  the Dilithium post -quantum  cryptographic \naccelerator with the miniNDN framework, ensuring robust security for future network \ncommunications. 18  4.4.1. Actor  Use Case  Diagram  \n \n \nFigure  4.2 Actor  Use Case  Diagram  \nFigure  4.2 presents  a use case diagram  describing  the interac tion between  various  actors  in the Athestia \nsystem, which secures data exchange using post -quantum cryptography, specifically the Dilithium \nalgorithm, and certificates managed by  the Certificate Authority  (CA) within the NDN framework. Actors:  \n1. Consumer:  Requests  data and verifies  the authenticity  and integrity  of data packets. 2. Producer:  Provides  data packets  and ensures  they are signed and certified. 3. Dilithium:  A post-quantum  cryptographic  algorithm  used for key generation,  signing,  and \nsignature verification. 4. Certificate  Authority  (CA):  Responsible for  signing  and certifying  public  keys. 5. NDN  Router:  Forwards  and stores  interest  and data packets  within  the network. 19  Use Case  Breakdown:  \n1. Consumer  Use Cases:  \n\u25cb Generate  interest  packet:  Consumer  generates  a request  for data (interest  packet). \u25cb Receive  data packet:  The consumer  receives  a data packet  from  the producer."
    ]
  },
  {
    "question": "What does Dilithium generate the public key and secret key for the producer?",
    "answer": "PK",
    "supporting_passages": [
      "\u25cb Request to verify  producer\u2019s PK from  CA\u2019s PK: Verifies the producer's public key by \nchecking the CA's signed certificate. \u25cb Request  to verify  Data  packet  from  producer\u2019s  PK: Verifies  the received  data packet  by \nusing the producer's public key. \u25cb Check  signature:  Ensures  that the  data packet's  signature  is valid. 2. Producer Use  Cases:  \n\u25cb Receive interest packet: The producer receives the interest packet from the consumer \nvia the NDN router. \u25cb Request  to generate keys: The producer requests Dilithium to generate a public and  \nprivate key pair (PK and SK). \u25cb Receive  keys:  The producer receives  the generated  keys from  Dilithi um. \u25cb Request  for PK certificate  from  CA: Producer  requests  the CA to sign the public  key. \u25cb Request to sign data from  producer's secret key: Signs the outgoing data packet using \nthe producer\u2019s secret key. \u25cb Get & provide a signed data packet to the network: The  producer provides the signed \ndata packet to the network for forwarding to the consumer. 3. Dilithium  Use Cases:  \n\u25cb Generate  PK and SK: Dilithium  generates  the public  key (PK) and secret key  (SK) for \nthe producer."
    ]
  },
  {
    "question": "What does Dilithium generate for the producer?",
    "answer": "public  key (PK) and secret key",
    "supporting_passages": [
      "\u25cb Request to verify  producer\u2019s PK from  CA\u2019s PK: Verifies the producer's public key by \nchecking the CA's signed certificate. \u25cb Request  to verify  Data  packet  from  producer\u2019s  PK: Verifies  the received  data packet  by \nusing the producer's public key. \u25cb Check  signature:  Ensures  that the  data packet's  signature  is valid. 2. Producer Use  Cases:  \n\u25cb Receive interest packet: The producer receives the interest packet from the consumer \nvia the NDN router. \u25cb Request  to generate keys: The producer requests Dilithium to generate a public and  \nprivate key pair (PK and SK). \u25cb Receive  keys:  The producer receives  the generated  keys from  Dilithi um. \u25cb Request  for PK certificate  from  CA: Producer  requests  the CA to sign the public  key. \u25cb Request to sign data from  producer's secret key: Signs the outgoing data packet using \nthe producer\u2019s secret key. \u25cb Get & provide a signed data packet to the network: The  producer provides the signed \ndata packet to the network for forwarding to the consumer. 3. Dilithium  Use Cases:  \n\u25cb Generate  PK and SK: Dilithium  generates  the public  key (PK) and secret key  (SK) for \nthe producer."
    ]
  },
  {
    "question": "What does the NDN router do to generate a digital signature?",
    "answer": "using the secret key for data integrity",
    "supporting_passages": [
      "\u25cb Generate signature: Creates a digital signature  using the secret key for data integrity  \nand authenticity. \u25cb Verify  signature:  Verifies  the signature  using  the public  key. 4. Certificate  Authority  (CA)  Use Cases:  \n\u25cb Request  for signing  the PK: The CA signs  the producer\u2019s  public  key, certifying  its \nauthenticity. 20  5. NDN  Router  Use Cases:  \n\u25cb Check  interest  packet  is available:  The NDN  router  verifies  if the interest  packet  exists \nin its cache. \u25cb Forward  interest  packet:  Routes  the interest  packet  from  the consumer to  the producer. \u25cb Forward  & store  data packet:  Forwards  the signed  data packet  from  the producer  to the \nconsumer and stores it if necessary. 4.4.2. Activity  Diagram  \n \nFigure  4.3 Activity  Swim  Line Diagram  of Athestia\n\n \n21   \nFigure 4.3 illustrates  the process of  certificate -based trust management in  a Named Data Networking \n(NDN) system, integrated with the post -quantum cryptographic algorithm Dilithium for secure key  \nand signature management. The diagram  includes five key  actors:  the consumer, the NDN router, the \nproducer, the Dili thium cryptosystem, and the Certificate Authority (CA). 1. Consumer:  \n\u25cb Connect to NDN Network: The consumer node connects to the NDN network."
    ]
  },
  {
    "question": "What does the NDN router do to generate a digital signature using the secret key?",
    "answer": "data integrity  \nand authenticity",
    "supporting_passages": [
      "\u25cb Generate signature: Creates a digital signature  using the secret key for data integrity  \nand authenticity. \u25cb Verify  signature:  Verifies  the signature  using  the public  key. 4. Certificate  Authority  (CA)  Use Cases:  \n\u25cb Request  for signing  the PK: The CA signs  the producer\u2019s  public  key, certifying  its \nauthenticity. 20  5. NDN  Router  Use Cases:  \n\u25cb Check  interest  packet  is available:  The NDN  router  verifies  if the interest  packet  exists \nin its cache. \u25cb Forward  interest  packet:  Routes  the interest  packet  from  the consumer to  the producer. \u25cb Forward  & store  data packet:  Forwards  the signed  data packet  from  the producer  to the \nconsumer and stores it if necessary. 4.4.2. Activity  Diagram  \n \nFigure  4.3 Activity  Swim  Line Diagram  of Athestia\n\n \n21   \nFigure 4.3 illustrates  the process of  certificate -based trust management in  a Named Data Networking \n(NDN) system, integrated with the post -quantum cryptographic algorithm Dilithium for secure key  \nand signature management. The diagram  includes five key  actors:  the consumer, the NDN router, the \nproducer, the Dili thium cryptosystem, and the Certificate Authority (CA). 1. Consumer:  \n\u25cb Connect to NDN Network: The consumer node connects to the NDN network."
    ]
  },
  {
    "question": "How does the consumer verify the producer's public key?",
    "answer": "checking the certificate provided by the \nCA",
    "supporting_passages": [
      "It \nalready possesses the CA's public key (PK), which is necessary for verifying trust. \u25cb Generate  Interest  Packet:  The consumer  generates  an Interest  Packet  to request  data. \u25cb Receive  Data  Packet:  After  the Interest  Packet is  processed,  the consumer  receives  the \nrequested data packet from the producer. \u25cb Verify Chain of Trust: The consumer initiates a verification process to ensure the \nauthenticity of the producer\u2019s public key by checking the certificate provided by the \nCA. \u25cb Request to Verify Producer\u2019s PK from CA: The consumer asks the CA to verify the  \nproducer\u2019s public key by using its certificate. \u25cb Check  Signature  Verification:  The consumer  checks  if the producer\u2019s  signature  can be \nverified. If the verification fails, the process ends with a false return. \u25cb Request to Verify  Data Packet from  Producer\u2019s  PK: O nce the producer\u2019s  public key  is \nverified, the consumer requests to verify  the data packet using that public key. \u25cb Check  Data  Packet  Signature:  The consumer  checks  the signature  on the data packet. If \nverified successfully, it returns true; otherwise, it returns false. 2. NDN  Router:  \n\u25cb Check  Neighbouring  Nodes: The  router first  checks  for any available  neighbouring \nnodes in the network."
    ]
  },
  {
    "question": "What is the CA's public key?",
    "answer": "PK",
    "supporting_passages": [
      "It \nalready possesses the CA's public key (PK), which is necessary for verifying trust. \u25cb Generate  Interest  Packet:  The consumer  generates  an Interest  Packet  to request  data. \u25cb Receive  Data  Packet:  After  the Interest  Packet is  processed,  the consumer  receives  the \nrequested data packet from the producer. \u25cb Verify Chain of Trust: The consumer initiates a verification process to ensure the \nauthenticity of the producer\u2019s public key by checking the certificate provided by the \nCA. \u25cb Request to Verify Producer\u2019s PK from CA: The consumer asks the CA to verify the  \nproducer\u2019s public key by using its certificate. \u25cb Check  Signature  Verification:  The consumer  checks  if the producer\u2019s  signature  can be \nverified. If the verification fails, the process ends with a false return. \u25cb Request to Verify  Data Packet from  Producer\u2019s  PK: O nce the producer\u2019s  public key  is \nverified, the consumer requests to verify  the data packet using that public key. \u25cb Check  Data  Packet  Signature:  The consumer  checks  the signature  on the data packet. If \nverified successfully, it returns true; otherwise, it returns false. 2. NDN  Router:  \n\u25cb Check  Neighbouring  Nodes: The  router first  checks  for any available  neighbouring \nnodes in the network."
    ]
  },
  {
    "question": "What does the NDN router forward to the producer when an Interest Packet is available?",
    "answer": "the  \npacket",
    "supporting_passages": [
      "\u25cb Check Interest Packet Availability: If an Interest Packet is available,  it forwards the  \npacket  to the producer. If no packet  is available,  the router  does not forward  the request. \u25cb Forward Interest Packet: If  conditions are met, the Interest Packet is forwarded to the \nappropriate producer. \u25cb Forward & Store Data Packet: Once the producer generates a data packet, the router  \nforwards  it to the consumer and may store it for future requests. 22   \n3. Producer:  \n\u25cb Receive  Interest  Packet:  The producer  receives  the Interest  Packet  from  the NDN \nrouter. \u25cb Request  to Generate  Public  and Secret  Key:  Upon receiving  an Interest  Packet, the \nproducer initiates a request to generate a public key (PK) and a secret key (SK). \u25cb Receive  PK & SK: The producer  receives  the generated  public  and secret  keys from  the \nDilithium cryptosystem. \u25cb Request PK  Certificate from  CA: The producer sends a request to the CA  to receive a \nsigned certificate for its public key. \u25cb Get Signed  Public  Key from  CA: The CA signs  the producer\u2019s  public  key and sends  the \nsigned certificate back to the producer."
    ]
  },
  {
    "question": "What does the NDN router forward to the producer if an Interest Packet is available?",
    "answer": "the  \npacket",
    "supporting_passages": [
      "\u25cb Check Interest Packet Availability: If an Interest Packet is available,  it forwards the  \npacket  to the producer. If no packet  is available,  the router  does not forward  the request. \u25cb Forward Interest Packet: If  conditions are met, the Interest Packet is forwarded to the \nappropriate producer. \u25cb Forward & Store Data Packet: Once the producer generates a data packet, the router  \nforwards  it to the consumer and may store it for future requests. 22   \n3. Producer:  \n\u25cb Receive  Interest  Packet:  The producer  receives  the Interest  Packet  from  the NDN \nrouter. \u25cb Request  to Generate  Public  and Secret  Key:  Upon receiving  an Interest  Packet, the \nproducer initiates a request to generate a public key (PK) and a secret key (SK). \u25cb Receive  PK & SK: The producer  receives  the generated  public  and secret  keys from  the \nDilithium cryptosystem. \u25cb Request PK  Certificate from  CA: The producer sends a request to the CA  to receive a \nsigned certificate for its public key. \u25cb Get Signed  Public  Key from  CA: The CA signs  the producer\u2019s  public  key and sends  the \nsigned certificate back to the producer."
    ]
  },
  {
    "question": "What steps are used to create a secure signed data packet?",
    "answer": "Generate  Signature",
    "supporting_passages": [
      "\u25cb Request  to Sign Data  Packet:  After  obtaining  the signed  public  key, the producer  sends \na request to the Dilithium system to sign the data packet using its secret key. \u25cb Get Signed  Data  Packet:  The producer  receives  the signed  data packet,  which  is \nforwarded to the consumer via the NDN router. # \n \n \n \n \n \n \n \n \n \n \n4. Dilithium:  \n\u25cb Generate  PK and SK: This step involves  the generation  of the  public  key (PK)  and \nsecret key (SK) using the Dilithium key algorithm. \u25cb Generate  Signature:  The producer\u2019s  data packet  is signed  using  the Dilithium  signature \nalgorithm, creating a secure signed data packet. \u25cb Verify Signature: When requested, Dilithium verifies the signatures using the public \nkey and the verify algorithm. 5. Certificate  Authority  (CA):  \n\u25cb Request  to Sign PK: The CA receives  a request  to sign the producer\u2019s  public  key. \u25cb Generate Signature: The  CA signs the producer\u2019s public key and returns a certificate \nthat links  the key to the producer,  providing  a chain  of trust for the consumer  to verify. This process ensures that the consumer can  trust the data packets received from  the producer  through \nthe verification of certificates and signatures using the Dilithium post -quantum cryptosystem. 23  4.4.3."
    ]
  },
  {
    "question": "How does the consumer verify the data packets received from the producer?",
    "answer": "verification of certificates and signatures",
    "supporting_passages": [
      "\u25cb Request  to Sign Data  Packet:  After  obtaining  the signed  public  key, the producer  sends \na request to the Dilithium system to sign the data packet using its secret key. \u25cb Get Signed  Data  Packet:  The producer  receives  the signed  data packet,  which  is \nforwarded to the consumer via the NDN router. # \n \n \n \n \n \n \n \n \n \n \n4. Dilithium:  \n\u25cb Generate  PK and SK: This step involves  the generation  of the  public  key (PK)  and \nsecret key (SK) using the Dilithium key algorithm. \u25cb Generate  Signature:  The producer\u2019s  data packet  is signed  using  the Dilithium  signature \nalgorithm, creating a secure signed data packet. \u25cb Verify Signature: When requested, Dilithium verifies the signatures using the public \nkey and the verify algorithm. 5. Certificate  Authority  (CA):  \n\u25cb Request  to Sign PK: The CA receives  a request  to sign the producer\u2019s  public  key. \u25cb Generate Signature: The  CA signs the producer\u2019s public key and returns a certificate \nthat links  the key to the producer,  providing  a chain  of trust for the consumer  to verify. This process ensures that the consumer can  trust the data packets received from  the producer  through \nthe verification of certificates and signatures using the Dilithium post -quantum cryptosystem. 23  4.4.3."
    ]
  },
  {
    "question": "What is the name of the unit that manages the storage and retrieval of cryptographic keys and other necessary data?",
    "answer": "Memory Controller",
    "supporting_passages": [
      "Operational  Diagram  \n \n \nFigure  4.4 Operational  Diagram  \n\n \n24  Figure  4.4 outlines  the communication  process  between  a Laptop  and a Dilithium  Accelerator  using  a \nUART Protocol, facilitating cryptographic operations for secure data exchange. 1. Laptop  Interface:  \n\u25cb The laptop  represents  the user's  system,  which  interacts  with the Dilithium  Accelerator. \u25cb Application:  Runs  software  that generates  data for transmission. \u25cb Bitstream  Generation: Converts  data into a  bitstream  to be transmitted  via UART. \u25cb UART Driver: The driver responsible for managing the transmission of data through \nthe UART interface, converting the bitstream into TX (Transmit) and RX (Receive) \nsignals. 2. UART  Protocol:  \n\u25cb The UART Protocol  is used to establish serial  communication between  the laptop  and \nthe Dilithium Accelerator. \u25a0 The TX (Transmit)  line sends  the data bitstream  from  the laptop  to the \naccelerator. \u25a0 RX (Receive)  line collects  responses from  the accelerator back  to the laptop. 3. Dilithium  Accelerator:  \n\u25cb The Dilithium  Accelerator  handles  cryptographic  operations  including  key generation, \nsigning, and signature verification. \u25a0 Control Unit:  Central unit  that directs  the flow of data  and controls  various \noperations within the accelerator. \u25a0 Memory Controller: Manages storage and retrieval of cryptographic keys and \nother necessary data."
    ]
  },
  {
    "question": "What is the name of the device used to communicate between a laptop and a Dilithium Accelerator?",
    "answer": "The TX (Transmit)",
    "supporting_passages": [
      "Operational  Diagram  \n \n \nFigure  4.4 Operational  Diagram  \n\n \n24  Figure  4.4 outlines  the communication  process  between  a Laptop  and a Dilithium  Accelerator  using  a \nUART Protocol, facilitating cryptographic operations for secure data exchange. 1. Laptop  Interface:  \n\u25cb The laptop  represents  the user's  system,  which  interacts  with the Dilithium  Accelerator. \u25cb Application:  Runs  software  that generates  data for transmission. \u25cb Bitstream  Generation: Converts  data into a  bitstream  to be transmitted  via UART. \u25cb UART Driver: The driver responsible for managing the transmission of data through \nthe UART interface, converting the bitstream into TX (Transmit) and RX (Receive) \nsignals. 2. UART  Protocol:  \n\u25cb The UART Protocol  is used to establish serial  communication between  the laptop  and \nthe Dilithium Accelerator. \u25a0 The TX (Transmit)  line sends  the data bitstream  from  the laptop  to the \naccelerator. \u25a0 RX (Receive)  line collects  responses from  the accelerator back  to the laptop. 3. Dilithium  Accelerator:  \n\u25cb The Dilithium  Accelerator  handles  cryptographic  operations  including  key generation, \nsigning, and signature verification. \u25a0 Control Unit:  Central unit  that directs  the flow of data  and controls  various \noperations within the accelerator. \u25a0 Memory Controller: Manages storage and retrieval of cryptographic keys and \nother necessary data."
    ]
  },
  {
    "question": "What is responsible for generating the public and private keys used in the cryptographic process?",
    "answer": "Key Generation",
    "supporting_passages": [
      "\u25a0 Key Generation:  Responsible  for generating  the public  and private  keys used in \nthe cryptographic process. \u25a0 Signature  Unit:  Signs  outgoing  data packets  to ensure  their authenticity. \u25a0 Verifier  Unit:  Verifies  incoming  data packets  using  the public  key to  check \nwhether the signature is valid. 4. Data  Flow:  \n\u25cb The Bitstream  sent by  the laptop  via the UART interface is  processed  by the Dilithium \nAccelerator. 25  \u25cb The processed data, including cryptographic signatures or verification results, is sent \nback to the laptop using the RX line of the UART Protocol. \u25cb The final output  includes  the public  key, signature,  and the verification  result \n(verified/not verified) as needed by the system. This diagram  demonstrates  the interaction  between  the laptop  and the Dilithium  Accelerator  for secure \ncommunication, highlighting the role of t he UART Protocol in transmitting data between the two \ncomponents for cryptographic processing. 4.5. Requirements  \nThe system is designed with a clear set of functional and non -functional requirements to ensure its \neffectiveness,  security,  and adaptability  within  a post-quantum  secure  Named  Data  Networking  (NDN) \nenvironment. Functionally,  the system  enables  users  to sign and verify  data packets  using  the Dilithium \nalgorithm, ensuring communication integrity and resistance to quantum attacks."
    ]
  },
  {
    "question": "What is responsible for generating the public and private keys?",
    "answer": "Key Generation",
    "supporting_passages": [
      "\u25a0 Key Generation:  Responsible  for generating  the public  and private  keys used in \nthe cryptographic process. \u25a0 Signature  Unit:  Signs  outgoing  data packets  to ensure  their authenticity. \u25a0 Verifier  Unit:  Verifies  incoming  data packets  using  the public  key to  check \nwhether the signature is valid. 4. Data  Flow:  \n\u25cb The Bitstream  sent by  the laptop  via the UART interface is  processed  by the Dilithium \nAccelerator. 25  \u25cb The processed data, including cryptographic signatures or verification results, is sent \nback to the laptop using the RX line of the UART Protocol. \u25cb The final output  includes  the public  key, signature,  and the verification  result \n(verified/not verified) as needed by the system. This diagram  demonstrates  the interaction  between  the laptop  and the Dilithium  Accelerator  for secure \ncommunication, highlighting the role of t he UART Protocol in transmitting data between the two \ncomponents for cryptographic processing. 4.5. Requirements  \nThe system is designed with a clear set of functional and non -functional requirements to ensure its \neffectiveness,  security,  and adaptability  within  a post-quantum  secure  Named  Data  Networking  (NDN) \nenvironment. Functionally,  the system  enables  users  to sign and verify  data packets  using  the Dilithium \nalgorithm, ensuring communication integrity and resistance to quantum attacks."
    ]
  },
  {
    "question": "What does the system empower system administrators to generate, manage, and monitor cryptographic keys and the overall performance of the Dilithium accelerator to maintain operational efficiency within the NDN framework?",
    "answer": "\n",
    "supporting_passages": [
      "It also empowers  \nsystem administrators to generate, manage, and monitor cryptographic keys and the overall \nperformance of the Dilithium accelerator to maintain operational efficiency within the NDN \nframework. These capabilities are expressed through user stories that guid e system behavior and \ndevelopment  priorities. On the non-functional  side,  the system  is expected  to deliver  high performance \nwith minimal latency while meeting stringent security requirements based on NIST post -quantum \ncryptographic  standards. The design  emphasizes  maintainability  through  a modular  codebase,  allowing \nfor future updates and debugging with minimal disruption. Furthermore, the system is built to be \ninteroperable  with existing  NDN  infrastructures,  ensuring  seamless  integration  and adaptability  across \na variety of secure network environments. 4.5.1. Functional  Requirements  \nThe following user stories represent the functional requirements of  the system, defined in a standard \nformat:  \n1. As a User , I want  to sign data packets  using  the Dilithium  algorithm  so that my communication \nremains secure against quantum attacks. 2. As a System  Administrator , I want to generate and manage cryptographic keys  so that I  can \nensure secure signing and verification operations. 3."
    ]
  },
  {
    "question": "What does the system empower system administrators to generate, manage, and monitor cryptographic keys and the overall performance of the Dilithium accelerator?",
    "answer": "NDN \nframework",
    "supporting_passages": [
      "It also empowers  \nsystem administrators to generate, manage, and monitor cryptographic keys and the overall \nperformance of the Dilithium accelerator to maintain operational efficiency within the NDN \nframework. These capabilities are expressed through user stories that guid e system behavior and \ndevelopment  priorities. On the non-functional  side,  the system  is expected  to deliver  high performance \nwith minimal latency while meeting stringent security requirements based on NIST post -quantum \ncryptographic  standards. The design  emphasizes  maintainability  through  a modular  codebase,  allowing \nfor future updates and debugging with minimal disruption. Furthermore, the system is built to be \ninteroperable  with existing  NDN  infrastructures,  ensuring  seamless  integration  and adaptability  across \na variety of secure network environments. 4.5.1. Functional  Requirements  \nThe following user stories represent the functional requirements of  the system, defined in a standard \nformat:  \n1. As a User , I want  to sign data packets  using  the Dilithium  algorithm  so that my communication \nremains secure against quantum attacks. 2. As a System  Administrator , I want to generate and manage cryptographic keys  so that I  can \nensure secure signing and verification operations. 3."
    ]
  },
  {
    "question": "What are the non-functional requirements for the project?",
    "answer": "essential performance, \nsecurity, and scalability standards",
    "supporting_passages": [
      "As a User , I want  to verify  the integrity  of the received  data packets  using  the Dilithium \nalgorithm so that I can trust that the data has not been tampered with. 26  4. As a System Administrator , I want to monitor  the performance of  the Dilithium accelerator \nso that I can ensure its efficient operation within the NDN network. 4.5.2. Non-Functional  Requirements  \nThe non -functional requirements for the project ensure that the system meets essential performance, \nsecurity, and scalability standards. The system must perform efficiently, processing inputs and \ngenerating  outputs  with minimal  delay. In terms  of security,  the system  must  provide  quantum -resistant \nencryption according to NIST standards, ensuring that communication channels are secure and \ncryptographic keys remain protected from unauthorized access. The system's modular codebase ensures easy maintainability, allowing for efficient updates and \ndebugging. Compliance with NIST post -quantum standards to ensure data privacy and security. Additionally, the system is interoperable with existing NDN frameworks, f acilitating seamless \nintegration with other cryptographic systems. 27   \n5."
    ]
  },
  {
    "question": "What are the non functional requirements for the project?",
    "answer": "essential performance, \nsecurity, and scalability standards",
    "supporting_passages": [
      "As a User , I want  to verify  the integrity  of the received  data packets  using  the Dilithium \nalgorithm so that I can trust that the data has not been tampered with. 26  4. As a System Administrator , I want to monitor  the performance of  the Dilithium accelerator \nso that I can ensure its efficient operation within the NDN network. 4.5.2. Non-Functional  Requirements  \nThe non -functional requirements for the project ensure that the system meets essential performance, \nsecurity, and scalability standards. The system must perform efficiently, processing inputs and \ngenerating  outputs  with minimal  delay. In terms  of security,  the system  must  provide  quantum -resistant \nencryption according to NIST standards, ensuring that communication channels are secure and \ncryptographic keys remain protected from unauthorized access. The system's modular codebase ensures easy maintainability, allowing for efficient updates and \ndebugging. Compliance with NIST post -quantum standards to ensure data privacy and security. Additionally, the system is interoperable with existing NDN frameworks, f acilitating seamless \nintegration with other cryptographic systems. 27   \n5."
    ]
  },
  {
    "question": "What is the main component of the Dilithium Hardware Accelerator?",
    "answer": "FPGA",
    "supporting_passages": [
      "Software  design  and modeling  \nThis chapter provides a comprehensive overview of the project architecture and design diagrams, \nhighlighting the integration of post -quant um cryptographic operations within the Named Data \nNetworking (NDN) framework. 5.1. Project  Architecture  \nThe architecture of the project follows a modular design approach, strategically dividing \nresponsibilities across specialized components to ensure scalabili ty, efficiency, and maintainability. This approach  integrates  hardware  acceleration,  network  simulation,  and cryptographic  protocols  into \na cohesive  framework. Each  module  is designed  to perform  a specific  role while  interfacing  seamlessly \nwith others, creating a  robust system  for post -quantum  cryptography  within Named Data  Networking \n(NDN). 5.1.1. Main  Components:  \n5.1.1.1. Dilithium  Hardware  Accelerator  \nThis is a custom -designed module implemented  on an FPGA,  tasked  with executing  post-quantum \ncryptographic operations, including key generation, digital signature creation, and signature \nverification. \u25cf Hardware  acceleration  significantly  boosts  the speed  of cryptographic  computations  compared \nto software implementations. \u25cf It offloads cryptographic processing from the CPU, reducing the overall computational load \nand power consumption. \u25cf Designed with scalability in mind, allowing adaptation to future cryptographic algorithms if \nrequired. 5.1.1.2. MiniNDN  Framework  \nMiniNDN  serves  as a lightweight  simulation  environment  for implementing  and testing  NDN  \nprotocols and features."
    ]
  },
  {
    "question": "What is the main component of the NDN project?",
    "answer": "hardware  acceleration",
    "supporting_passages": [
      "Software  design  and modeling  \nThis chapter provides a comprehensive overview of the project architecture and design diagrams, \nhighlighting the integration of post -quant um cryptographic operations within the Named Data \nNetworking (NDN) framework. 5.1. Project  Architecture  \nThe architecture of the project follows a modular design approach, strategically dividing \nresponsibilities across specialized components to ensure scalabili ty, efficiency, and maintainability. This approach  integrates  hardware  acceleration,  network  simulation,  and cryptographic  protocols  into \na cohesive  framework. Each  module  is designed  to perform  a specific  role while  interfacing  seamlessly \nwith others, creating a  robust system  for post -quantum  cryptography  within Named Data  Networking \n(NDN). 5.1.1. Main  Components:  \n5.1.1.1. Dilithium  Hardware  Accelerator  \nThis is a custom -designed module implemented  on an FPGA,  tasked  with executing  post-quantum \ncryptographic operations, including key generation, digital signature creation, and signature \nverification. \u25cf Hardware  acceleration  significantly  boosts  the speed  of cryptographic  computations  compared \nto software implementations. \u25cf It offloads cryptographic processing from the CPU, reducing the overall computational load \nand power consumption. \u25cf Designed with scalability in mind, allowing adaptation to future cryptographic algorithms if \nrequired. 5.1.1.2. MiniNDN  Framework  \nMiniNDN  serves  as a lightweight  simulation  environment  for implementing  and testing  NDN  \nprotocols and features."
    ]
  },
  {
    "question": "What is a key feature of the UART protocol?",
    "answer": "reliable,  bidirectional  data transfer",
    "supporting_passages": [
      "\u25cf miniNDN  is modified  to interface  with the Dilithium  hardware  accelerator,  enabling \ncryptographic operations for data integrity and authenticity within the NDN simulation. \u25cf Supports  self-certifying  data packets, leveraging  post-quantum  cryptographic  signatures. \u25cf Provides a controlled environment for simulating network behaviors without requiring a full - \nscale deployment. 28  5.1.1.3. UART  Protocol  \nThe Universal Asynchr onous Receiver -Transmitter (UART) protocol acts as the communication \nbridge between the software -based miniNDN framework and the hardware accelerator. \u25cf UART  ensures  reliable,  bidirectional  data transfer  between  the host CPU  and the FPGA \nmodule. \u25cf Designed  to handle  asynchronous  communication,  providing  flexibility  for various  clock \ndomains in the system. \u25cf Enables  a low-overhead,  high-speed  interface  for transferring  cryptographic  requests  and \nresponses. 5.1.2. Key Features  of Architecture:  \nSeparation  of Concerns  \n \n\u25cf The project  design  separates  hardware  responsibilities  (e.g.,  cryptographic  computations)  from \nsoftware functionalities (e.g., NDN packet handling and network simulation). \u25cf This decoupling  simplifies  system  design,  debugging,  and maintenance. It also allows \nindividual modules to be developed, tested, and upgraded independently. Optimized  Performance  \n \n\u25cf Leveraging  the parallel  processing  capabilities  of the FPGA  ensures  cryptographic \ncomputations are executed efficiently."
    ]
  },
  {
    "question": "What does the UART protocol do?",
    "answer": "acts as the communication \nbridge",
    "supporting_passages": [
      "\u25cf miniNDN  is modified  to interface  with the Dilithium  hardware  accelerator,  enabling \ncryptographic operations for data integrity and authenticity within the NDN simulation. \u25cf Supports  self-certifying  data packets, leveraging  post-quantum  cryptographic  signatures. \u25cf Provides a controlled environment for simulating network behaviors without requiring a full - \nscale deployment. 28  5.1.1.3. UART  Protocol  \nThe Universal Asynchr onous Receiver -Transmitter (UART) protocol acts as the communication \nbridge between the software -based miniNDN framework and the hardware accelerator. \u25cf UART  ensures  reliable,  bidirectional  data transfer  between  the host CPU  and the FPGA \nmodule. \u25cf Designed  to handle  asynchronous  communication,  providing  flexibility  for various  clock \ndomains in the system. \u25cf Enables  a low-overhead,  high-speed  interface  for transferring  cryptographic  requests  and \nresponses. 5.1.2. Key Features  of Architecture:  \nSeparation  of Concerns  \n \n\u25cf The project  design  separates  hardware  responsibilities  (e.g.,  cryptographic  computations)  from \nsoftware functionalities (e.g., NDN packet handling and network simulation). \u25cf This decoupling  simplifies  system  design,  debugging,  and maintenance. It also allows \nindividual modules to be developed, tested, and upgraded independently. Optimized  Performance  \n \n\u25cf Leveraging  the parallel  processing  capabilities  of the FPGA  ensures  cryptographic \ncomputations are executed efficiently."
    ]
  },
  {
    "question": "What is the name of the layer that is responsible for executing post -quantum cryptographic operations using the Dilithium cryptographic scheme on an FPGA?",
    "answer": "hardware layer",
    "supporting_passages": [
      "\u25cf The hardware  acceleration  significantly  reduces  latency  in key cryptographic  operations,  such \nas signature creation and verification, enhancing overall system throughput. 5.2. Architecture  Used:  \nThe system employs multi -layered architecture, with each layer serving a distinct role to enable \nseamles s integration of hardware -based cryptographic operations with Named Data Networking \n(NDN)  features. This design  ensures  clarity  of responsibilities, improved  performance,  and scalability \nfor future enhancements  \n \n \n \n \n29  5.2.1. Hardware  Layer  \nThe hardware layer is the f oundation of the architecture, responsible for executing post -quantum \ncryptographic operations using the Dilithium cryptographic scheme on an FPGA. Dilithium  Hardware  Accelerator : \n \n\u25cf Performs computationally intensive tasks such as key generation, digital signature creation, \nand signature verification. \u25cf Optimized  for high throughput  and low latency, leveraging  the parallel  processing  capabilities \nof FPGAs. Custom  FPGA  Design : \n \nDeveloped using hardware description languages like VHDL or SystemVerilog. Incorpo rates  modularity  to allow  updates  or extensions  for future  cryptographic  algorithms  \n \n5.2.2. Middleware  Layer  \nThis layer  bridges  the hardware  accelerator  and the miniNDN  framework,  ensuring  smooth \ncommunication and coordination between the hardware and software components. UART  Protocol : \n \n\u25cf Serves as the communication backbone between the host system  (running miniNDN) and the \nFPGA -based hardware accelerator."
    ]
  },
  {
    "question": "What is the name of the layer that is responsible for executing post -quantum cryptographic operations with Named Data Networking?",
    "answer": "Middleware  Layer",
    "supporting_passages": [
      "\u25cf The hardware  acceleration  significantly  reduces  latency  in key cryptographic  operations,  such \nas signature creation and verification, enhancing overall system throughput. 5.2. Architecture  Used:  \nThe system employs multi -layered architecture, with each layer serving a distinct role to enable \nseamles s integration of hardware -based cryptographic operations with Named Data Networking \n(NDN)  features. This design  ensures  clarity  of responsibilities, improved  performance,  and scalability \nfor future enhancements  \n \n \n \n \n29  5.2.1. Hardware  Layer  \nThe hardware layer is the f oundation of the architecture, responsible for executing post -quantum \ncryptographic operations using the Dilithium cryptographic scheme on an FPGA. Dilithium  Hardware  Accelerator : \n \n\u25cf Performs computationally intensive tasks such as key generation, digital signature creation, \nand signature verification. \u25cf Optimized  for high throughput  and low latency, leveraging  the parallel  processing  capabilities \nof FPGAs. Custom  FPGA  Design : \n \nDeveloped using hardware description languages like VHDL or SystemVerilog. Incorpo rates  modularity  to allow  updates  or extensions  for future  cryptographic  algorithms  \n \n5.2.2. Middleware  Layer  \nThis layer  bridges  the hardware  accelerator  and the miniNDN  framework,  ensuring  smooth \ncommunication and coordination between the hardware and software components. UART  Protocol : \n \n\u25cf Serves as the communication backbone between the host system  (running miniNDN) and the \nFPGA -based hardware accelerator."
    ]
  },
  {
    "question": "What is the purpose of the NDN Framework Integration?",
    "answer": "Facilitates asynchronous bidirectional data transfer",
    "supporting_passages": [
      "\u25cf Facilitates asynchronous bidirectional data transfer, making it possible to send cryptographic \nrequests and receive responses efficiently  \nInterface  Logic : \n \n\u25cf Designed  to handle  protocol -specific  data formatting, packetizing, and  error  handling for  robust \ncommunication. \u25cf Acts as a translator  between  the digital  signals  of the FPGA  and the application  data structures \nin the miniNDN framework  \n\u25cf The application  layer  focuses  on implementing  and enhancing  NDN  protocols,  ensuring  secure \ncommunication by integrating the Dilithium -based cryptographic operations. 30  Self-Certifying  Data  Packets : \n \n\u25cf Modified  NDN  packets  include  post-quantum  secure  digital  signatures  generated  by the \nhardware accelerator. \u25cf Self-certification ensures that the authenticity and integrity of the data can be independently \nverified by any node in the network without relying on a central authority  \n \nMiniNDN  Framework  Integration : \n \n\u25cf The NDN  simulation  environment  is enhanced  to suppor t post-quantum  cryptographic \nmechanisms. \u25cf This allows  developers  to test and refine  secure  communication  processes  in a controlled \nnetwork simulation  \n \n \n5.3. Design  Diagrams:  \nTo provide a comprehensive understanding of  the system's architecture, functionality, and data flow, \nmultiple UML diagrams have been developed. These diagrams clarify the interactions between \ncomponents,  the static  and dynamic  structures  of the system,  and the organization  of data storage."
    ]
  },
  {
    "question": "What does the self-certification function do?",
    "answer": "ensures that the authenticity and integrity of the data can be independently \nverified",
    "supporting_passages": [
      "\u25cf Facilitates asynchronous bidirectional data transfer, making it possible to send cryptographic \nrequests and receive responses efficiently  \nInterface  Logic : \n \n\u25cf Designed  to handle  protocol -specific  data formatting, packetizing, and  error  handling for  robust \ncommunication. \u25cf Acts as a translator  between  the digital  signals  of the FPGA  and the application  data structures \nin the miniNDN framework  \n\u25cf The application  layer  focuses  on implementing  and enhancing  NDN  protocols,  ensuring  secure \ncommunication by integrating the Dilithium -based cryptographic operations. 30  Self-Certifying  Data  Packets : \n \n\u25cf Modified  NDN  packets  include  post-quantum  secure  digital  signatures  generated  by the \nhardware accelerator. \u25cf Self-certification ensures that the authenticity and integrity of the data can be independently \nverified by any node in the network without relying on a central authority  \n \nMiniNDN  Framework  Integration : \n \n\u25cf The NDN  simulation  environment  is enhanced  to suppor t post-quantum  cryptographic \nmechanisms. \u25cf This allows  developers  to test and refine  secure  communication  processes  in a controlled \nnetwork simulation  \n \n \n5.3. Design  Diagrams:  \nTo provide a comprehensive understanding of  the system's architecture, functionality, and data flow, \nmultiple UML diagrams have been developed. These diagrams clarify the interactions between \ncomponents,  the static  and dynamic  structures  of the system,  and the organization  of data storage."
    ]
  },
  {
    "question": "What is the purpose of a Object Diagram?",
    "answer": "ensuring  clear  communication  and alignment \namong team members and stakeholders",
    "supporting_passages": [
      "Each \ndiagram  serves  a specific  purpose  in the design  process,  ensuring  clear  communication  and alignment \namong team members and stakeholders. 5.3.1. Object  Diagram  \nThe object diagram provides a snapshot of the system at runtime, focusing on the objects involved  \nand their relationships during operation . 31   \nFigure  5.1 Object  Diagram  \n \nFigure 5.1 is an instance -level representation of the class diagram, showcasing specific objects and \ntheir interactions in a real -world scenario. It provides a concrete view of how the system operates, \nemphasizing the dynamic rel ationships between instances of classes. Request  and Response  Process  \n\u25cf A Consumer  object  initiates  a request  by creating  an Interest  Packet  object  with attributes  such \nas Interest_id, name, and nonce. This  packet travels  through  the network,  eventually reaching \na Producer object. \u25cf The Producer object responds by generating a Data Packet object. This packet includes the \nrequested  data, along  with a Dilithium  Signature  created  using  the producer\u2019s  secret_key. The \nproducer\u2019s public key and certificate are in cluded to verify the authenticity of the response. Cryptographic  Operations  in Action  \n\u25cf Instances of the Key Pair Generation, Signature, and Verification classes demonstrate \ncryptographic  workflows."
    ]
  },
  {
    "question": "What is the purpose of the diagram?",
    "answer": "ensuring  clear  communication  and alignment \namong team members and stakeholders",
    "supporting_passages": [
      "Each \ndiagram  serves  a specific  purpose  in the design  process,  ensuring  clear  communication  and alignment \namong team members and stakeholders. 5.3.1. Object  Diagram  \nThe object diagram provides a snapshot of the system at runtime, focusing on the objects involved  \nand their relationships during operation . 31   \nFigure  5.1 Object  Diagram  \n \nFigure 5.1 is an instance -level representation of the class diagram, showcasing specific objects and \ntheir interactions in a real -world scenario. It provides a concrete view of how the system operates, \nemphasizing the dynamic rel ationships between instances of classes. Request  and Response  Process  \n\u25cf A Consumer  object  initiates  a request  by creating  an Interest  Packet  object  with attributes  such \nas Interest_id, name, and nonce. This  packet travels  through  the network,  eventually reaching \na Producer object. \u25cf The Producer object responds by generating a Data Packet object. This packet includes the \nrequested  data, along  with a Dilithium  Signature  created  using  the producer\u2019s  secret_key. The \nproducer\u2019s public key and certificate are in cluded to verify the authenticity of the response. Cryptographic  Operations  in Action  \n\u25cf Instances of the Key Pair Generation, Signature, and Verification classes demonstrate \ncryptographic  workflows."
    ]
  },
  {
    "question": "What does the Key Pair Generation object generate that is used by the Signature object to sign the Data Packet?",
    "answer": "keys",
    "supporting_passages": [
      "For example,  the Key Pair Generation  object  generates  keys that are \nused by the Signature object to sign the Data Packet. The Verification object validates this \n\n \n32  signature, ensuring the data's integrity and authenticity. \u25cf The Dilithium  Accelerator  object  optimizes  the signing  and verification  processes,  showcasing \nhardware acceleration for cryptographic computations. Routing  and Packet Handling  \n\u25cf A Router object processes packets in transit, utilizing attributes like cache_capacity and \nforwarding_table  to route  packets  efficiently. Interest packets  are matched  with cached  data or \nforwarded based on the pending_interest_table, while data packets are stored temporarily for \nquick retrieval. Certificate  Management  \n\u25cf The Certificate  Authority  object issues certificates  to the Producer  and Consumer  objects. The \nIssue  Digital  Certificates  object ensures  that all  certificates  are valid and traceable  to a trusted \nauthority. This process establishes a chain of trust, enabling secure communication. 5.3.2. Class  Diagram  \nThe class diagram provides a static view of the system, detailing its  structure through classes, their \nattributes, methods, and relationships. Figure  5.2 Class  Diagram  \n\n \n33  Figure 5.2 depicts the structural framework of a system integrating Named Data Networking (NDN) \nand Dilithium  post-quantum cryptography, highlighting the essential classes, their attributes, and \nbehaviors."
    ]
  },
  {
    "question": "What does the Key Pair Generation object generate that are used by the Signature object to sign the Data Packet?",
    "answer": "keys",
    "supporting_passages": [
      "For example,  the Key Pair Generation  object  generates  keys that are \nused by the Signature object to sign the Data Packet. The Verification object validates this \n\n \n32  signature, ensuring the data's integrity and authenticity. \u25cf The Dilithium  Accelerator  object  optimizes  the signing  and verification  processes,  showcasing \nhardware acceleration for cryptographic computations. Routing  and Packet Handling  \n\u25cf A Router object processes packets in transit, utilizing attributes like cache_capacity and \nforwarding_table  to route  packets  efficiently. Interest packets  are matched  with cached  data or \nforwarded based on the pending_interest_table, while data packets are stored temporarily for \nquick retrieval. Certificate  Management  \n\u25cf The Certificate  Authority  object issues certificates  to the Producer  and Consumer  objects. The \nIssue  Digital  Certificates  object ensures  that all  certificates  are valid and traceable  to a trusted \nauthority. This process establishes a chain of trust, enabling secure communication. 5.3.2. Class  Diagram  \nThe class diagram provides a static view of the system, detailing its  structure through classes, their \nattributes, methods, and relationships. Figure  5.2 Class  Diagram  \n\n \n33  Figure 5.2 depicts the structural framework of a system integrating Named Data Networking (NDN) \nand Dilithium  post-quantum cryptography, highlighting the essential classes, their attributes, and \nbehaviors."
    ]
  },
  {
    "question": "What class is responsible for initiating requests for data by generating interest packets?",
    "answer": "\nConsumer",
    "supporting_passages": [
      "Each class serves a specific role in achieving secure and efficient communication. Core  Components:  \n\u25cf The Consumer and Producer classes form the fundamental endp oints of the system. The \nConsumer is responsible for initiating requests for data by generating interest packets, while \nthe Producer provides signed data packets in response to these requests. Both classes include \nattributes such as public_key, certificate , and cryptographic methods to ensure secure \nexchanges. \u25cf The Interest Packet and Data Packet classes handle the transport of requests and responses \nwithin the network. Interest Packet includes attributes like Interest_id, name, and nonce to \nidentify  and secure requests,  while  Data  Packet  contains  name,  data,  and a Dilithium  Signature \nto ensure the integrity and authenticity of the response. Cryptographic  Operations:  \n\u25cf Cryptographic  processes  are managed  by specialized  classes. The  Keypair Generation  class is \nresponsible  for creating  public -private  key pairs,  essential  for signing  and verifying  operations. The Signature class  provides methods  for signing messages, utilizing attributes like Message, \nsecret_key, and ctx (context). The Verification class ensures t he validity of received data by \nverifying the signature against the sender's public key. Each of these classes encapsulates \nspecific cryptographic algorithms, including NTT, expandA, hashing, and sampleInBall."
    ]
  },
  {
    "question": "What is the Consumer class responsible for initiating requests for data by generating interest packets?",
    "answer": "\nConsumer",
    "supporting_passages": [
      "Each class serves a specific role in achieving secure and efficient communication. Core  Components:  \n\u25cf The Consumer and Producer classes form the fundamental endp oints of the system. The \nConsumer is responsible for initiating requests for data by generating interest packets, while \nthe Producer provides signed data packets in response to these requests. Both classes include \nattributes such as public_key, certificate , and cryptographic methods to ensure secure \nexchanges. \u25cf The Interest Packet and Data Packet classes handle the transport of requests and responses \nwithin the network. Interest Packet includes attributes like Interest_id, name, and nonce to \nidentify  and secure requests,  while  Data  Packet  contains  name,  data,  and a Dilithium  Signature \nto ensure the integrity and authenticity of the response. Cryptographic  Operations:  \n\u25cf Cryptographic  processes  are managed  by specialized  classes. The  Keypair Generation  class is \nresponsible  for creating  public -private  key pairs,  essential  for signing  and verifying  operations. The Signature class  provides methods  for signing messages, utilizing attributes like Message, \nsecret_key, and ctx (context). The Verification class ensures t he validity of received data by \nverifying the signature against the sender's public key. Each of these classes encapsulates \nspecific cryptographic algorithms, including NTT, expandA, hashing, and sampleInBall."
    ]
  },
  {
    "question": "What does the Dilithium Accelerator class handle?",
    "answer": "key  generation, signing, and \nverification at high speed",
    "supporting_passages": [
      "\u25cf The Dilithium Accelerator class is a hardware -oriented module designed to optimize the \nexecution  of cryptographic operations. It handles operations like key  generation, signing, and \nverification at high speed. Trust  and Certification:  \n\u25cf Trust  management  is handled  by the Certificate  Authority  and Issue  Digital  Certificates  classes. These ensure that producers and consumers have valid credentials, using attributes like \ncertificate_id, trust_anchor, and public_key. The methods issue_certificate() and \ngenerateCertificate() ensure secure issuance and manage ment of certificates. Routing  and Packet Management:  \n\u25cf The Router Packets - Router class handles the forwarding and caching of packets across the \nnetwork. Attributes  like router_id,  cache_capacity,  and forwarding_table  support  efficient  data \n \n34  delivery, while  methods like routePacket(Packet) and storePacket(Packet) ensure proper \nhandling of network packets. 5.4. Behavioral  Diagrams  \nBehavioral diagrams focus on capturing the dynamic processes and workflows of the system. They \nprovide insight into how various components interact during runtime, how tasks are performed step - \nby-step, and how the system transitions between different operational states. These diagrams are \ninstrumental in understanding the system's behavior under different scenarios, such as crypto graphic \noperations and network communication. 35  5.4.1."
    ]
  },
  {
    "question": "What does the Dilithium Accelerator class do?",
    "answer": "optimize the \nexecution  of cryptographic operations",
    "supporting_passages": [
      "\u25cf The Dilithium Accelerator class is a hardware -oriented module designed to optimize the \nexecution  of cryptographic operations. It handles operations like key  generation, signing, and \nverification at high speed. Trust  and Certification:  \n\u25cf Trust  management  is handled  by the Certificate  Authority  and Issue  Digital  Certificates  classes. These ensure that producers and consumers have valid credentials, using attributes like \ncertificate_id, trust_anchor, and public_key. The methods issue_certificate() and \ngenerateCertificate() ensure secure issuance and manage ment of certificates. Routing  and Packet Management:  \n\u25cf The Router Packets - Router class handles the forwarding and caching of packets across the \nnetwork. Attributes  like router_id,  cache_capacity,  and forwarding_table  support  efficient  data \n \n34  delivery, while  methods like routePacket(Packet) and storePacket(Packet) ensure proper \nhandling of network packets. 5.4. Behavioral  Diagrams  \nBehavioral diagrams focus on capturing the dynamic processes and workflows of the system. They \nprovide insight into how various components interact during runtime, how tasks are performed step - \nby-step, and how the system transitions between different operational states. These diagrams are \ninstrumental in understanding the system's behavior under different scenarios, such as crypto graphic \noperations and network communication. 35  5.4.1."
    ]
  },
  {
    "question": "What is a typical interaction between the consumer, NDN Router, Producer, Dilithium cryptographic module, and Certificate Authority?",
    "answer": "securely exchange data",
    "supporting_passages": [
      "Sequence  Diagram  \nVisualizes the interaction between  system  components during a typical  operation, such  as processing \na data request. Figure  5.3 Sequence Diagram  \nFigure 5.3 illustrates th e interactions among the Consumer, NDN Router, Producer, Dilithium \ncryptographic module, and Certificate Authority (CA) to securely exchange data in a Named Data \nNetworking (NDN) system. The process begins with the Consumer generating an Interest Packet \ncontaining  the identifier  and name  of the requested  data. This packet  is forwarded  to the NDN  Router, \nwhich checks  its cache  for the requested  content. If the  content  is available,  the router  forwards the  \n\n \n36  Data Packet directly to the Consumer. Otherwise, the Interest Packet is forwarded to the Producer \nresponsible for the data. Upon receiving the Interest Packet, the Producer initiates the generation of public and private keys \nusing the Dilithium  cryptographic module. A  request is then  sent to the Certificate Authority  to issue \na signed  digital  certificate  for the generated  public  key. Once  the CA verifies  the request  and signs  the \npublic  key, the Producer  uses the private  key to sign the requested  data,  creating  a Signed  Data  Packet."
    ]
  },
  {
    "question": "What is the sequence diagram of the interaction between the consumer, NDN Router, Producer, Dilithium cryptographic module, and Certificate Authority?",
    "answer": "Figure  5.3",
    "supporting_passages": [
      "Sequence  Diagram  \nVisualizes the interaction between  system  components during a typical  operation, such  as processing \na data request. Figure  5.3 Sequence Diagram  \nFigure 5.3 illustrates th e interactions among the Consumer, NDN Router, Producer, Dilithium \ncryptographic module, and Certificate Authority (CA) to securely exchange data in a Named Data \nNetworking (NDN) system. The process begins with the Consumer generating an Interest Packet \ncontaining  the identifier  and name  of the requested  data. This packet  is forwarded  to the NDN  Router, \nwhich checks  its cache  for the requested  content. If the  content  is available,  the router  forwards the  \n\n \n36  Data Packet directly to the Consumer. Otherwise, the Interest Packet is forwarded to the Producer \nresponsible for the data. Upon receiving the Interest Packet, the Producer initiates the generation of public and private keys \nusing the Dilithium  cryptographic module. A  request is then  sent to the Certificate Authority  to issue \na signed  digital  certificate  for the generated  public  key. Once  the CA verifies  the request  and signs  the \npublic  key, the Producer  uses the private  key to sign the requested  data,  creating  a Signed  Data  Packet."
    ]
  },
  {
    "question": "What does the Dilithium cryptographic module verify the consumer's public key and the received data packet?",
    "answer": "the signature",
    "supporting_passages": [
      "This packet  is then forwarded  back to the NDN  Router,  which  stores  it and forwards  it to the Consumer. To ensure authenticity, the Consumer requests verification of the Producer\u2019s public key and the \nreceived  data packet. The Dilithium  cryptographic  module  verifies  the signature  against  the public  key \nissued by  the CA. If  the signature matches, the verification  succeeds, and the Consumer is  assured of \nthe data\u2019s integrity  and authenticity. In case of  verification failure, the process terminates, indicating \nan issue with the data or its source. The sequence diagram effectively showcases the step -by-step \nsecure communication flow, leveraging Dilithium post -quantum cryptography and a trusted CA. 5.5. User  Interface  Design  \n \n\n \n37   \n \n \n \n \n\n \n38   \n \n\n \n39   \n\n \n40  6. Algorithm  analysis  and complexity  \n \n6.1. Introduction  \nThis chapter explores the foundational algorithms deployed in our project, focusing on their critical \nrole in enhancing the system's efficiency and effectiveness. We dissect the algorithms implemented, \nscrutinizing  their design,  purpose,  and significance  to the overarching  goals  of the project. The chapter \nprovides  a comparative  analysis  of these  algorithms  against  other  cryptographic methods,  specifically \nexamining their time and space complexities."
    ]
  },
  {
    "question": "What does the Dilithium cryptographic module verify?",
    "answer": "the signature",
    "supporting_passages": [
      "This packet  is then forwarded  back to the NDN  Router,  which  stores  it and forwards  it to the Consumer. To ensure authenticity, the Consumer requests verification of the Producer\u2019s public key and the \nreceived  data packet. The Dilithium  cryptographic  module  verifies  the signature  against  the public  key \nissued by  the CA. If  the signature matches, the verification  succeeds, and the Consumer is  assured of \nthe data\u2019s integrity  and authenticity. In case of  verification failure, the process terminates, indicating \nan issue with the data or its source. The sequence diagram effectively showcases the step -by-step \nsecure communication flow, leveraging Dilithium post -quantum cryptography and a trusted CA. 5.5. User  Interface  Design  \n \n\n \n37   \n \n \n \n \n\n \n38   \n \n\n \n39   \n\n \n40  6. Algorithm  analysis  and complexity  \n \n6.1. Introduction  \nThis chapter explores the foundational algorithms deployed in our project, focusing on their critical \nrole in enhancing the system's efficiency and effectiveness. We dissect the algorithms implemented, \nscrutinizing  their design,  purpose,  and significance  to the overarching  goals  of the project. The chapter \nprovides  a comparative  analysis  of these  algorithms  against  other  cryptographic methods,  specifically \nexamining their time and space complexities."
    ]
  },
  {
    "question": "What is the purpose and significance of the Dilithium algorithm?",
    "answer": "operational \nmechanisms",
    "supporting_passages": [
      "This detailed exploration is intended to furnish a \ncomprehensive understanding of the algorithms\u2019 functionalities and their impact on the project. 6.2. Dilithium  Algorithms  \nAs cryptographic  research  advances  in response  to emerging  threats,  Dilithium has  gained  recognition \nas one of the most reliable digital signature algorithms for post -quantum  security. Developed as part \nof the NIST post -quantum cryptography standardization process, it offers  a powerful and efficient \nalternative to legacy algorithms like RSA and ECC, which are vulnerable in the face of quantum \ncomputing. The following subsections delve into the specific purpose, significance, and operational \nmechanisms  of the Dilithium  algorit hm, providing  both conceptual  understanding  and technical  insight \ninto how it functions within our system. This includes a breakdown  of its cryptographic strength  and \npseudocode  that captures its key processes, such as key generation, signing, and verification. 6.2.1. Purpose  and Significance  \nThe Dilithium  algorithm  is at the  forefront  of our digital  defenses,  acting  as a digital  signature  scheme \ndesigned to withstand the formidable powers of  quantum  computing. As we edge closer to the era of \nquantum compu ters, traditional cryptographic methods like RSA and ECC are under threat."
    ]
  },
  {
    "question": "What is the purpose of Dilithium Algorithms?",
    "answer": "cryptographic  research  advances  in response  to emerging  threats",
    "supporting_passages": [
      "This detailed exploration is intended to furnish a \ncomprehensive understanding of the algorithms\u2019 functionalities and their impact on the project. 6.2. Dilithium  Algorithms  \nAs cryptographic  research  advances  in response  to emerging  threats,  Dilithium has  gained  recognition \nas one of the most reliable digital signature algorithms for post -quantum  security. Developed as part \nof the NIST post -quantum cryptography standardization process, it offers  a powerful and efficient \nalternative to legacy algorithms like RSA and ECC, which are vulnerable in the face of quantum \ncomputing. The following subsections delve into the specific purpose, significance, and operational \nmechanisms  of the Dilithium  algorit hm, providing  both conceptual  understanding  and technical  insight \ninto how it functions within our system. This includes a breakdown  of its cryptographic strength  and \npseudocode  that captures its key processes, such as key generation, signing, and verification. 6.2.1. Purpose  and Significance  \nThe Dilithium  algorithm  is at the  forefront  of our digital  defenses,  acting  as a digital  signature  scheme \ndesigned to withstand the formidable powers of  quantum  computing. As we edge closer to the era of \nquantum compu ters, traditional cryptographic methods like RSA and ECC are under threat."
    ]
  },
  {
    "question": "What are the core functions of the Dilithium algorithm?",
    "answer": "operations within polynomial rings",
    "supporting_passages": [
      "These \nmethods depend heavily on the complexities of factorization and elliptic curve calculations \u2014 \nchallenges  that quantum  computers  are equipped to solve easily. Enter  Dilithium: a  robust alternative \nrooted  in lattice -based cryptography. This method  leans  on the complexities  of lattice problems, such \nas the Shortest  Vector Problem  (SVP), which  are tough  nuts to crack,  even for quantum  technologies. This makes  Dilithium  a cornerstone  in our quest for  a crypto system  that remains secure against both \ntoday's and tomorrow's cyber threats. 41  6.2.2. Pseudocode  and Operation  \nHere,  we outline  the core functions  of the Dilithium  algorithm,  encapsulated  in pseudocode  to illustrate \nits operational mechanics clearly:  \nKey Generation:  \n \n \n \n\n \n42  Signature:  \n \n \n\n \n43  Verification:  \n \n \n \n\n \n44  6.2.3 Comparison  with Other  Post-Quantum  Cryptographic  Algorithms  \nWhen  assessing  the landscape  of post-quantum  cryptographic  algorithms,  particularly  digital  signature \nschemes, it is  essential  to compare Dilithium with  other signature algorithms  such as Falcon. Each  of \nthese algorithms brings unique strengths and potential  drawbacks, tailored to different security  needs \nand computational environments. Dilithium  vs. Falcon:  \n \n\u25cf Algorithmic  Foundations:  \n\u25cb Dilithium is based on the hardness of the Ring -Learning with Errors (Ring -LWE) \nproblem, which involves operations within polynomial rings."
    ]
  },
  {
    "question": "What is the core function of the Dilithium algorithm?",
    "answer": "operations within polynomial rings",
    "supporting_passages": [
      "These \nmethods depend heavily on the complexities of factorization and elliptic curve calculations \u2014 \nchallenges  that quantum  computers  are equipped to solve easily. Enter  Dilithium: a  robust alternative \nrooted  in lattice -based cryptography. This method  leans  on the complexities  of lattice problems, such \nas the Shortest  Vector Problem  (SVP), which  are tough  nuts to crack,  even for quantum  technologies. This makes  Dilithium  a cornerstone  in our quest for  a crypto system  that remains secure against both \ntoday's and tomorrow's cyber threats. 41  6.2.2. Pseudocode  and Operation  \nHere,  we outline  the core functions  of the Dilithium  algorithm,  encapsulated  in pseudocode  to illustrate \nits operational mechanics clearly:  \nKey Generation:  \n \n \n \n\n \n42  Signature:  \n \n \n\n \n43  Verification:  \n \n \n \n\n \n44  6.2.3 Comparison  with Other  Post-Quantum  Cryptographic  Algorithms  \nWhen  assessing  the landscape  of post-quantum  cryptographic  algorithms,  particularly  digital  signature \nschemes, it is  essential  to compare Dilithium with  other signature algorithms  such as Falcon. Each  of \nthese algorithms brings unique strengths and potential  drawbacks, tailored to different security  needs \nand computational environments. Dilithium  vs. Falcon:  \n \n\u25cf Algorithmic  Foundations:  \n\u25cb Dilithium is based on the hardness of the Ring -Learning with Errors (Ring -LWE) \nproblem, which involves operations within polynomial rings."
    ]
  },
  {
    "question": "What is Falcon's security derived from the difficulty of solving problems on classical and quantum computers?",
    "answer": "\u25cb",
    "supporting_passages": [
      "Its security  is derived \nfrom  the difficulty  of solving  these  problems  both on classical  and quantum  computers. \u25cb Falcon uses the NTRU problem  combined with the Fast Fourier Transform  (FFT) for \nefficient polynomial multiplication. It stands out for its use of small keys and fast \noperations, which are beneficial for environments where bandwidth and storage are \nconcerned. \u25cf Performance  and Efficiency:  \n\u25cb Dilithium offers a robust balance betwe en signature size and verification speed, \nmaking  it well-suited  for systems  where  these  factors  are crucial. It provides  flexibility \nin terms  of trade -offs between  key size, signature  size, and security  level,  which  can be \nadjusted according to specific needs. \u25cb Falcon excels in  environments where smaller signature sizes are critical. It has one of \nthe smallest signature sizes among post -quantum candidates, which is particularly \nadvantageous for systems where bandwidth savings are paramount. \u25cf Security:  \n\u25cb Both Dilithium and Falcon are considered secure against known quantum attacks. Dilithium's security parameters can be scaled to meet various levels of quantum \nresistance,  allowing  it to be tailored  to the expected  capabilities  of quantum  computers."
    ]
  },
  {
    "question": "What is Falcon's security derived from the difficulty of solving classical and quantum computers?",
    "answer": "\u25cb",
    "supporting_passages": [
      "Its security  is derived \nfrom  the difficulty  of solving  these  problems  both on classical  and quantum  computers. \u25cb Falcon uses the NTRU problem  combined with the Fast Fourier Transform  (FFT) for \nefficient polynomial multiplication. It stands out for its use of small keys and fast \noperations, which are beneficial for environments where bandwidth and storage are \nconcerned. \u25cf Performance  and Efficiency:  \n\u25cb Dilithium offers a robust balance betwe en signature size and verification speed, \nmaking  it well-suited  for systems  where  these  factors  are crucial. It provides  flexibility \nin terms  of trade -offs between  key size, signature  size, and security  level,  which  can be \nadjusted according to specific needs. \u25cb Falcon excels in  environments where smaller signature sizes are critical. It has one of \nthe smallest signature sizes among post -quantum candidates, which is particularly \nadvantageous for systems where bandwidth savings are paramount. \u25cf Security:  \n\u25cb Both Dilithium and Falcon are considered secure against known quantum attacks. Dilithium's security parameters can be scaled to meet various levels of quantum \nresistance,  allowing  it to be tailored  to the expected  capabilities  of quantum  computers."
    ]
  },
  {
    "question": "What is Falcon's use case suitability?",
    "answer": "IoT devices or  other bandwidth - \nconstrained environments",
    "supporting_passages": [
      "\u25cb Falcon offers a high level  of security  even  with smaller keys and signatures, although \nthe complexity of its implementation and the need for careful parameter selection to \navoid vulnerabilities are notable considerations. \u25cf Implementation  Considerations:  \n\u25cb Dilithium  is straightforward to implement with existing cryptographic libraries that  \n \n45  support lattice -based operations. Its reliance on well -understood algebraic structures \nmakes  it less susceptible  to implementation  errors  that could  compromise  security. \u25cb Falcon requires careful implementation, especially in handling polynomial arithmetic \nsecurely and efficiently. The use of FFT -based techniques, while providing speed \nadvantages, also necessitates precision to prevent side -channel attac ks. \u25cf Use Case  Suitability:  \n\u25cb Dilithium is particularly effective in standard digital signature applications such as \nsecuring software distribution, document signing, and identity verification, where its \nbalance of security and performance is valuable. \u25cb Falcon is suited for applications where the efficiency  of signature verification  and the \nminimization of  signature size are critical, such as in IoT devices or  other bandwidth - \nconstrained environments. 6.3. COMPLEXITY  ANALYSIS  AND  OPTIMIZATION  \nUnderstanding t he computational demands and efficiency of the algorithms we implement is crucial \nfor optimizing the performance and reliability of our system."
    ]
  },
  {
    "question": "What is the use case of Falcon?",
    "answer": "IoT devices",
    "supporting_passages": [
      "\u25cb Falcon offers a high level  of security  even  with smaller keys and signatures, although \nthe complexity of its implementation and the need for careful parameter selection to \navoid vulnerabilities are notable considerations. \u25cf Implementation  Considerations:  \n\u25cb Dilithium  is straightforward to implement with existing cryptographic libraries that  \n \n45  support lattice -based operations. Its reliance on well -understood algebraic structures \nmakes  it less susceptible  to implementation  errors  that could  compromise  security. \u25cb Falcon requires careful implementation, especially in handling polynomial arithmetic \nsecurely and efficiently. The use of FFT -based techniques, while providing speed \nadvantages, also necessitates precision to prevent side -channel attac ks. \u25cf Use Case  Suitability:  \n\u25cb Dilithium is particularly effective in standard digital signature applications such as \nsecuring software distribution, document signing, and identity verification, where its \nbalance of security and performance is valuable. \u25cb Falcon is suited for applications where the efficiency  of signature verification  and the \nminimization of  signature size are critical, such as in IoT devices or  other bandwidth - \nconstrained environments. 6.3. COMPLEXITY  ANALYSIS  AND  OPTIMIZATION  \nUnderstanding t he computational demands and efficiency of the algorithms we implement is crucial \nfor optimizing the performance and reliability of our system."
    ]
  },
  {
    "question": "What is the worst case time complexity for the Dilithium Algorithm?",
    "answer": "O(n^2).",
    "supporting_passages": [
      "This section breaks down the time and \nspace complexities of the Dilithium algorithm, offering insights into how well it performs under \nvarious operational conditions and how we can tune these parameters for optimal performance. 6.3.1. Time  Complexity  \nDilithium  Algorithm:  \n \n\u25cf Best Case:  The best -case scenario for Dilithium occurs under conditions where the algorithm \nfaces minimal interference and optimal operational environment. In such situations, the time \ncomplexity is linear, denoted as O(n), where n represents the size of the input message. This \nscenario assumes  that the lattice  operations  and the hashing functions,  which are integral  parts \nof the signing and verification processes, execute without any computational delays. \u25cf Average Case:  The average case time complexity for Dilithium is typically O(n log n). This \nconsiders  the average performance and efficiency  of the un derlying lattice reduction  and hash \nfunction calculations during the signature generation and verification phases. The log factor \naccounts for the iterative process of reducing lattice dimensions to manageable levels, which \nis a key step in ensuring crypto graphic strength against potential quantum attacks. \u25cf Worst Case:  The worst -case time complexity is O(n^2)."
    ]
  },
  {
    "question": "What is the worst case time complexity for the Dilithium algorithm?",
    "answer": "O(n^2).",
    "supporting_passages": [
      "This section breaks down the time and \nspace complexities of the Dilithium algorithm, offering insights into how well it performs under \nvarious operational conditions and how we can tune these parameters for optimal performance. 6.3.1. Time  Complexity  \nDilithium  Algorithm:  \n \n\u25cf Best Case:  The best -case scenario for Dilithium occurs under conditions where the algorithm \nfaces minimal interference and optimal operational environment. In such situations, the time \ncomplexity is linear, denoted as O(n), where n represents the size of the input message. This \nscenario assumes  that the lattice  operations  and the hashing functions,  which are integral  parts \nof the signing and verification processes, execute without any computational delays. \u25cf Average Case:  The average case time complexity for Dilithium is typically O(n log n). This \nconsiders  the average performance and efficiency  of the un derlying lattice reduction  and hash \nfunction calculations during the signature generation and verification phases. The log factor \naccounts for the iterative process of reducing lattice dimensions to manageable levels, which \nis a key step in ensuring crypto graphic strength against potential quantum attacks. \u25cf Worst Case:  The worst -case time complexity is O(n^2)."
    ]
  },
  {
    "question": "What is the space complexity of the Dilithium Algorithm primarily influenced by the size of the keys and the signatures it generates?",
    "answer": "linearly  dependent on  the security  parameters",
    "supporting_passages": [
      "This scenario emerges under \nconditions where the lattice problems become exceptionally dense and the computational \n \n46  overhead peaks. Such  conditions might occur  with very  large input sizes or  when  the security  \nparameters require extremely high -dimensional lattices to thwart advanced quantum or \nclassical  attacks. In these instances,  the processing time increases  quadratically, reflecting the \nintensified  effort required to manage and simplify complex lattice structures. 6.3.2. Space  Complexity  \nDilithium  Algorithm:  \n \nThe space complexity of the Dilithium algorithm is primarily influenced by the size of the keys and \nthe signatures it generates. These factors  are linearly  dependent on  the security  parameters  chosen  for \nthe application, which are set based on the anticipated security  needs and the operational context:  \n\u25cf Key and Signature  Sizes:  The space  required  to store  the keys and signatures  increases  linearly \nwith their size, denoted  as O(n),  where  n refers  to the security  parameter  defining  the key length \nand the complexity of the signature. These parameters are adjustable, allowing for a flexible \napproach to balancing security and resource utilization. \u25cf Optimizatio n Considerations: Optimizing space complexity involves selecting appropriate \nsecurity parameters that do not overly burden the system's storage capabilities while still \nproviding robust security."
    ]
  },
  {
    "question": "What is the space complexity of the Dilithium Algorithm influenced by the size of the keys and the signatures it generates?",
    "answer": "linearly  dependent on  the security  parameters",
    "supporting_passages": [
      "This scenario emerges under \nconditions where the lattice problems become exceptionally dense and the computational \n \n46  overhead peaks. Such  conditions might occur  with very  large input sizes or  when  the security  \nparameters require extremely high -dimensional lattices to thwart advanced quantum or \nclassical  attacks. In these instances,  the processing time increases  quadratically, reflecting the \nintensified  effort required to manage and simplify complex lattice structures. 6.3.2. Space  Complexity  \nDilithium  Algorithm:  \n \nThe space complexity of the Dilithium algorithm is primarily influenced by the size of the keys and \nthe signatures it generates. These factors  are linearly  dependent on  the security  parameters  chosen  for \nthe application, which are set based on the anticipated security  needs and the operational context:  \n\u25cf Key and Signature  Sizes:  The space  required  to store  the keys and signatures  increases  linearly \nwith their size, denoted  as O(n),  where  n refers  to the security  parameter  defining  the key length \nand the complexity of the signature. These parameters are adjustable, allowing for a flexible \napproach to balancing security and resource utilization. \u25cf Optimizatio n Considerations: Optimizing space complexity involves selecting appropriate \nsecurity parameters that do not overly burden the system's storage capabilities while still \nproviding robust security."
    ]
  },
  {
    "question": "What is the purpose of Athestia: A Clean Slate Application?",
    "answer": "technical realization",
    "supporting_passages": [
      "This is particularly important in environments where memory \nresources   are  limited   or  where   system   efficiency   is  paramount. Techniques such as adjusting the lattice dimensions and exploring different configurations of \nlattice -based problems can help reduce the storage requirements without compromising the \ncryptographic integrity. Moreover, efficient memory management  practices and the use of \ncompact data structures are critical for minimizing the footprint of the cryptographic \noperations. 6.4. Discussion  \nThe selection  of the Dilithium  algorithm  for our project  reflects  a strategic  choice  to prioritize  security \nin the quan tum era. This decision  underscores  the importance  of adopting  cryptographic  solutions  that \nnot only meet current  security  standards but are  also forward  compatible  with emerging  technologies. 47  7. Implementation  \n \n7.1. CODE  \nThis chapter presents the technical realization of Athestia: A Clean Slate Application using Named \nData  Networking  (NDN)  and Dilithium. The implementation  integrates  a post-quantum  cryptographic \nsignature scheme (Dilithium) on hardware with a simulated NDN environment (MiniNDN)  on the \nsoftware side. Communication is established via the UART protocol, and key  modules are written in \nSystemVerilog for FPGA  and Python for software -side verification.Due to the complexity  and scale, \nthis chapter focuses on the core cryptographic opera tions, rather than presenting the full codebase."
    ]
  },
  {
    "question": "How does Athestia: A Clean Slate Application perform?",
    "answer": "technical realization",
    "supporting_passages": [
      "This is particularly important in environments where memory \nresources   are  limited   or  where   system   efficiency   is  paramount. Techniques such as adjusting the lattice dimensions and exploring different configurations of \nlattice -based problems can help reduce the storage requirements without compromising the \ncryptographic integrity. Moreover, efficient memory management  practices and the use of \ncompact data structures are critical for minimizing the footprint of the cryptographic \noperations. 6.4. Discussion  \nThe selection  of the Dilithium  algorithm  for our project  reflects  a strategic  choice  to prioritize  security \nin the quan tum era. This decision  underscores  the importance  of adopting  cryptographic  solutions  that \nnot only meet current  security  standards but are  also forward  compatible  with emerging  technologies. 47  7. Implementation  \n \n7.1. CODE  \nThis chapter presents the technical realization of Athestia: A Clean Slate Application using Named \nData  Networking  (NDN)  and Dilithium. The implementation  integrates  a post-quantum  cryptographic \nsignature scheme (Dilithium) on hardware with a simulated NDN environment (MiniNDN)  on the \nsoftware side. Communication is established via the UART protocol, and key  modules are written in \nSystemVerilog for FPGA  and Python for software -side verification.Due to the complexity  and scale, \nthis chapter focuses on the core cryptographic opera tions, rather than presenting the full codebase."
    ]
  },
  {
    "question": "What module implements the Dilithium Key Generation logic?",
    "answer": "7.1.2. Key_internal.sv",
    "supporting_passages": [
      "7.1.1.  main.py  \nThis file is the top -level  user interface script. It connects the user, NDN framework (MiniNDN), and \nthe Dilitium. 7.1.2. Key_internal.sv  \nThis module implements the Dilithium Key Generation logic."
    ]
  },
  {
    "question": "What is the top-level user interface script?",
    "answer": "main.py",
    "supporting_passages": [
      "7.1.1.  main.py  \nThis file is the top -level  user interface script. It connects the user, NDN framework (MiniNDN), and \nthe Dilitium. 7.1.2. Key_internal.sv  \nThis module implements the Dilithium Key Generation logic."
    ]
  },
  {
    "question": "if (shakeDone && shakeRst && shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn",
    "answer": "\ncountA + 1;  \n   ",
    "supporting_passages": [
      "It packs functions into a finite state \nmachine (FSM) to compute the public and secret keys in accordance with FIPS 204.  \nimport Dilithium_pkg::*;  \nfunction automatic logic [63:0] extend_bits2(  \n    input logic [3:0] value,  \n    input int target_width,  \n    input bit is_signed  \n); \n    logic [63:0] extended_value;  \n    int i; \n    extended_value[63:0] = value;  \n \n    if (is_signed) begin  \n        for (i = 4; i < target_width; i++)   \n            extended_value[i] = value[3];    \n    end else begin  \n        for (i = 4; i < target_width; i++)  \n            extended_value[i] = 1'b0;        \n    end \n     \n    return extended_value;  endfunction  \n \nmodule key_internal(  \n    input  logic clk, rst,  \n    input  logic [255:0] zeta,  \n    output logic final_done,  \n    output logic [39167:0] sk,  \n    output logic [20735:0] pk     \n); \n \n    logic [255:0] swapOut;  \n    SwapNibbles #(256) swap (  \n        .in(zeta),  \n        .out(swapOut)  \n    ); \n \n    logic shakeDone, shakeRst, expandA_rst, \nexpanda_done, s1_ntt_done, compute_t , \nshakeDone2, shakeStart;  \n \n48      logic ntt_module_rst, t_ntt_done, \nnttinv_done, nttinv_rst, nttnew_done, \npk_rst,sk_rst;  \n    logic [271:0] shakeIn;  \n    logic [511:0] shakeOut2;  \n    logic [1023:0] shakeOut;  \n    logic [20735:0] shakeIn2;  \n    logic [31:0] A [0:k -1] [0:l -1] [0:255];  \n    logic [3:0] count, ntt_count, nttinv_count, \nnttinv_count2;  \n    logic signed [($clog2(eta)+1):0] s1 [0:l -1] \n[0:255];  \n    logic signed [($clog2(eta)+1):0] s2 [0:k -1] \n[0:255];  \n    logic expands_done, rst_ntt, nttdone, \nntt_disabler;  \n    logic signed [63:0] w [0:255] , checking \n[0:255];  \n    logic [63:0] nttinv_w [0:255];  \n    logic signed [31:0] w_hat [0:255], s1_ntt \n[0:l-1] [0:255];  \n    logic [63:0] t_ntt [0:k -1] [0:255];  \n    logic [63:0] nttinv_w_hat [0:255];  \n    logic [2:0] i, j;  \n    logic [8:0] countA;  \n    logic [63:0] power2round_t;  \n    logic [9:0] power2round_t1;  \n    logic signed [12:0] power2round_t0;  \n    logic [63:0] power_t [0:k -1] [0:255];  \n    logic [9:0] power_t1 [0:k -1] [0:255];  \n    logic signed [12:0] power_t0 [0:k -1] \n[0:255];  \n    logic signed [12:0] sk_t0 [0:k -1] [0:255];  \n    logic [255:0] pkencode_rho;  \n    logic [9:0] pkencode_t1 [0:k -1] [0:255];        \n    logic pk_done;    \n    logic [63:0] t [0:k -1] [0:255];  \n     always_ff @(posedge clk or posedge rst) \nbegin  \n        if (rst)  begin  \n            shakeIn <= 272'd0;  \n            i = 0;  \n            j = 0;  \n            countA = 0;  \n            nttinv_count <= 0;  \n             \n            for (int m = 0; m < k; m = m + 1) \nbegin  \n                for (int n = 0; n < 256; n = n + 1) \nbegin  \n                    t_ntt[m][n] <= 32'd0;  \n                end \n            end \n        end else begin  \n            ntt_module_rst <= rst_ntt || nttdone;  \n            shakeIn <= {l[7:0], k[7:0], swapOut};  \n            if (shakeDone && expandA_rst === \n'x) expandA_rst <= 1;  \n            if (expandA_rst) expandA_rst <= 0;  \n            if (expands_done && rst_ntt === 'x) \nbegin  \n                rst_ntt <= 1;  \n                ntt_count <= 0;  \n                count <= 0;  \n            end  \n            if (count >= 0) co unt <= count + 1;  \n            if (expands_done && count == 1) \nrst_ntt <= 0;  \n            if (ntt_count < l && nttdone && \n~ntt_module_rst) begin  \n                s1_ntt[ntt_count] <= w_hat;  \n                ntt_count <= ntt_count + 1;  \n            end \n            if (ntt_count == l && s1_ntt_done \n=== 'x) begin  \n \n49                  s1_ntt_done <= 1;  \n                ntt_disabler <= 1;  \n            end \n            if (expands_done) begin  \n                for (int k = 0; k < 256; k++) begin  \n                    w[k] = \nexten d_bits2(s1[ntt_count][k], 64, 1);  \n                end \n            end \n            if (expanda_done && s1_ntt_done \n&& expands_done && t_ntt_done === 'x) \nbegin  \n                t_ntt[i][countA -1] <= \nt_ntt[i][countA -1] + (A[i][j][countA -1] * \ns1_ntt[j][countA -1]); \n                if (i == 7 && j == 6 && countA == \n256) begin  \n                    i <= 'x;  \n                    j <= 'x;  \n                    countA <= 'x;  \n                    t_ntt_done <= 1;  \n                end \n                if (countA < 256) countA  <= \ncountA + 1;  \n                else begin  \n                    countA <= 0;  \n                    if (j < l -1) j <= j + 1;  \n                    else begin  \n                        j <= 0;  \n                        if (i < k -1) i <= i + 1;  \n                        else i <= 0;  \n                    end \n                end \n            end \n            nttinv_rst <= nttinv_done || \nt_ntt_done;  \n            nttinv_w_hat <= t_ntt[nttinv_count2];  \n            if (nttinv_done && ~nttinv_rst) begin                  t[nttinv_coun t2] <= nttinv_w;                 \n                nttinv_count2 <= nttinv_count2 + \n1; \n            end \n            if (t_ntt_done) begin  \n                nttinv_count2 <= 0;  \n                nttinv_w_hat <= t_ntt[0];  \n                nttinv_count <= nttinv_coun t + 1;  \n                if (nttinv_count == 1) begin  \n                    t_ntt_done <= 0;    \n                end \n            end \n            if (nttinv_count2 == 8) begin  \n                nttinv_rst <= 'x;  \n                power2round_t <= t[j][countA] + \ns2[j][countA];  \n                power_t1[j][countA -1] <= \npower2round_t1;  \n                power_t0[j][countA -1] <= \npower2round_t0;  \n            if ((j == 7 && countA == 256)) begin  \n                countA <= 257;  \n            end else begin   \n                                        if (countA == 256) \nbegin  \n                                            countA <= 0;  \n                                            if (j == 7) be gin \n                                                j <= j;                                  \n                                            end else  \n                                                j <= j + 1 ; \n                                        end else begin  \n                                            countA <= \ncountA + 1;  \n                                        end \n                                    end              \n                            end \n    if (pk_rst && nttinv_count == 3) begin         \n        pkencode_rho <= shakeOut[255:0];  \n \n50          pkencode_t1 <= power_t1;  \n    end  \n            if (pk_rst && nttinv_count == 4) \nbegin  \n    pk_rst <= 0;  \n    nttinv_count <= nttinv_count;  \nend else if (j == 7 && countA == 257) begin  \n    if (pk_rst === 'x) begin  // First clock  \n        pk_rst <= 1;  \n        nttinv_count <= nttinv_count + 1;  \n    end  \n    if (pk_rst == 1) begin // Second clock  \n        pk_rst <= 1;  \n        nttinv_count <= nttinv_count + 1;  \n    end \nend \n \nif (pk_done && shakeRst === 'x) begin  \n     \n    shakeRst <= 1;  \nend \nif (shakeRst) begin  \n    shakeRst <= 0;  \n    shakeIn2 <= pk;  \nend \nif (pk_done && s hakeRst == 0) begin  \n    shakeStart <= 1;  \nend \nif (shakeDone2 && sk_rst === 'x) begin  \n    sk_rst <= 1;  \n    sk_t0 <= power_t0;  \n    for (int i = 0; i < k; i++) begin  \n      $write(\"sk_t0[%0d]: \", i);  \n      for (int j = 0; j < 256; j++) begin  \n        $write(\"%0d  \", power_t0[i][j]);  \n      end \n      $write(\" \\n\"); \n    end end else if (sk_rst) begin  \n    sk_rst <= 0;      \nend \n        end \n    end \n \n    sponge #(  \n        .msg_len(276),  \n        .d_len(1024),  \n        .capacity(512)  \n    ) shake256 (  \n        .clk(clk),  \n        .reset(rst),  \n        .start(1'b1),  \n        .message({4'b1111, shakeIn}),  \n        .z(shakeOut),  \n        .done(shakeDone)  \n    ); \n \n    ExpandA expandA (  \n        .clk(clk),  \n        .rst(expandA_rst),  \n        .start(shakeDone),  \n        .rho(shakeOut[255:0]),  \n        .A(A),  \n        .done(expanda_done)  \n    ); \n \n    ExpandS ExpandS (  \n        .clk(clk),  \n        .rst(expandA_rst),  \n        .start(shakeDone),  \n        .rho(shakeOut[767:256]),  \n        .s1(s1),  \n        .s2(s2),  \n        .done(expands_done)  \n    ); \n \n \n51      NTT #(.WIDTH(64)) NTT (  \n        .clk(clk),  \n        .rst(ntt_module_rst),  \n        .w(w),  \n        .w_hat(w_hat),  \n        .done(nttdone),  \n        .disabler(ntt_disabler)  \n    ); \n     \n    NTT_INV #(.WIDTH(64)) NTT_INV (  \n        .clk(clk),  \n        .rst(nttinv_rst ), \n        .w(nttinv_w),  \n        .w_hat(nttinv_w_hat),  \n        .done(nttinv_done)  \n    ); \n     \n    Power2round #(  \n            .T_WIDTH(64)  \n        ) uut (  \n            .t(power2round_t),  \n            .t1(power2round_t1),  \n            .t0(power2round_t0)  \n        ); \n         \n    PkEncode PkEncode (  \n                .clk(clk),  \n                .reset(pk_rst),  \n                .rho(pkencode_rho),  \n                .t1(pkencode_t1),  \n                .pk(pk),  \n                .valid(pk_done)  \n            );             \n    sponge #(  \n                    .msg_len(20740),  \n                    .d_len(512),  \n                    .capacity(512)  \n                ) shake256_compute_tr (  \n                    .clk(clk),  \n                    .reset(shakeRst),  \n                    .start( shakeStart),  \n                    .message({4'b1111, shakeIn2}),  \n                    .z(shakeOut2),  \n                    .done(shakeDone2)  \n                ); \nskEncode #(  \n                          \n                        .cols_l(l),  \n                        .rows_k(k),  \n                        .n(eta),  \n                        .d(d)  \n                    ) dut (  \n                    .clk(clk),  \n                    .rst(sk_rst),  \n                        .rho(shakeOut[255:0]),  \n                        .K(shakeOut[1023:76 8]), \n                        .tr(shakeOut2),  \n                        .s1(s1),  \n                        .s2(s2),  \n                        .t0(sk_t0),  \n                        .sk(sk),  \n                        .done(final_done)  \n                    );                 \nendmodule  \n \n \n52  \n  \n7.2."
    ]
  },
  {
    "question": "if (shakeDone && shakeRst && shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeIn2 & shakeOut",
    "answer": "\ncountA + 1;  \n   ",
    "supporting_passages": [
      "It packs functions into a finite state \nmachine (FSM) to compute the public and secret keys in accordance with FIPS 204.  \nimport Dilithium_pkg::*;  \nfunction automatic logic [63:0] extend_bits2(  \n    input logic [3:0] value,  \n    input int target_width,  \n    input bit is_signed  \n); \n    logic [63:0] extended_value;  \n    int i; \n    extended_value[63:0] = value;  \n \n    if (is_signed) begin  \n        for (i = 4; i < target_width; i++)   \n            extended_value[i] = value[3];    \n    end else begin  \n        for (i = 4; i < target_width; i++)  \n            extended_value[i] = 1'b0;        \n    end \n     \n    return extended_value;  endfunction  \n \nmodule key_internal(  \n    input  logic clk, rst,  \n    input  logic [255:0] zeta,  \n    output logic final_done,  \n    output logic [39167:0] sk,  \n    output logic [20735:0] pk     \n); \n \n    logic [255:0] swapOut;  \n    SwapNibbles #(256) swap (  \n        .in(zeta),  \n        .out(swapOut)  \n    ); \n \n    logic shakeDone, shakeRst, expandA_rst, \nexpanda_done, s1_ntt_done, compute_t , \nshakeDone2, shakeStart;  \n \n48      logic ntt_module_rst, t_ntt_done, \nnttinv_done, nttinv_rst, nttnew_done, \npk_rst,sk_rst;  \n    logic [271:0] shakeIn;  \n    logic [511:0] shakeOut2;  \n    logic [1023:0] shakeOut;  \n    logic [20735:0] shakeIn2;  \n    logic [31:0] A [0:k -1] [0:l -1] [0:255];  \n    logic [3:0] count, ntt_count, nttinv_count, \nnttinv_count2;  \n    logic signed [($clog2(eta)+1):0] s1 [0:l -1] \n[0:255];  \n    logic signed [($clog2(eta)+1):0] s2 [0:k -1] \n[0:255];  \n    logic expands_done, rst_ntt, nttdone, \nntt_disabler;  \n    logic signed [63:0] w [0:255] , checking \n[0:255];  \n    logic [63:0] nttinv_w [0:255];  \n    logic signed [31:0] w_hat [0:255], s1_ntt \n[0:l-1] [0:255];  \n    logic [63:0] t_ntt [0:k -1] [0:255];  \n    logic [63:0] nttinv_w_hat [0:255];  \n    logic [2:0] i, j;  \n    logic [8:0] countA;  \n    logic [63:0] power2round_t;  \n    logic [9:0] power2round_t1;  \n    logic signed [12:0] power2round_t0;  \n    logic [63:0] power_t [0:k -1] [0:255];  \n    logic [9:0] power_t1 [0:k -1] [0:255];  \n    logic signed [12:0] power_t0 [0:k -1] \n[0:255];  \n    logic signed [12:0] sk_t0 [0:k -1] [0:255];  \n    logic [255:0] pkencode_rho;  \n    logic [9:0] pkencode_t1 [0:k -1] [0:255];        \n    logic pk_done;    \n    logic [63:0] t [0:k -1] [0:255];  \n     always_ff @(posedge clk or posedge rst) \nbegin  \n        if (rst)  begin  \n            shakeIn <= 272'd0;  \n            i = 0;  \n            j = 0;  \n            countA = 0;  \n            nttinv_count <= 0;  \n             \n            for (int m = 0; m < k; m = m + 1) \nbegin  \n                for (int n = 0; n < 256; n = n + 1) \nbegin  \n                    t_ntt[m][n] <= 32'd0;  \n                end \n            end \n        end else begin  \n            ntt_module_rst <= rst_ntt || nttdone;  \n            shakeIn <= {l[7:0], k[7:0], swapOut};  \n            if (shakeDone && expandA_rst === \n'x) expandA_rst <= 1;  \n            if (expandA_rst) expandA_rst <= 0;  \n            if (expands_done && rst_ntt === 'x) \nbegin  \n                rst_ntt <= 1;  \n                ntt_count <= 0;  \n                count <= 0;  \n            end  \n            if (count >= 0) co unt <= count + 1;  \n            if (expands_done && count == 1) \nrst_ntt <= 0;  \n            if (ntt_count < l && nttdone && \n~ntt_module_rst) begin  \n                s1_ntt[ntt_count] <= w_hat;  \n                ntt_count <= ntt_count + 1;  \n            end \n            if (ntt_count == l && s1_ntt_done \n=== 'x) begin  \n \n49                  s1_ntt_done <= 1;  \n                ntt_disabler <= 1;  \n            end \n            if (expands_done) begin  \n                for (int k = 0; k < 256; k++) begin  \n                    w[k] = \nexten d_bits2(s1[ntt_count][k], 64, 1);  \n                end \n            end \n            if (expanda_done && s1_ntt_done \n&& expands_done && t_ntt_done === 'x) \nbegin  \n                t_ntt[i][countA -1] <= \nt_ntt[i][countA -1] + (A[i][j][countA -1] * \ns1_ntt[j][countA -1]); \n                if (i == 7 && j == 6 && countA == \n256) begin  \n                    i <= 'x;  \n                    j <= 'x;  \n                    countA <= 'x;  \n                    t_ntt_done <= 1;  \n                end \n                if (countA < 256) countA  <= \ncountA + 1;  \n                else begin  \n                    countA <= 0;  \n                    if (j < l -1) j <= j + 1;  \n                    else begin  \n                        j <= 0;  \n                        if (i < k -1) i <= i + 1;  \n                        else i <= 0;  \n                    end \n                end \n            end \n            nttinv_rst <= nttinv_done || \nt_ntt_done;  \n            nttinv_w_hat <= t_ntt[nttinv_count2];  \n            if (nttinv_done && ~nttinv_rst) begin                  t[nttinv_coun t2] <= nttinv_w;                 \n                nttinv_count2 <= nttinv_count2 + \n1; \n            end \n            if (t_ntt_done) begin  \n                nttinv_count2 <= 0;  \n                nttinv_w_hat <= t_ntt[0];  \n                nttinv_count <= nttinv_coun t + 1;  \n                if (nttinv_count == 1) begin  \n                    t_ntt_done <= 0;    \n                end \n            end \n            if (nttinv_count2 == 8) begin  \n                nttinv_rst <= 'x;  \n                power2round_t <= t[j][countA] + \ns2[j][countA];  \n                power_t1[j][countA -1] <= \npower2round_t1;  \n                power_t0[j][countA -1] <= \npower2round_t0;  \n            if ((j == 7 && countA == 256)) begin  \n                countA <= 257;  \n            end else begin   \n                                        if (countA == 256) \nbegin  \n                                            countA <= 0;  \n                                            if (j == 7) be gin \n                                                j <= j;                                  \n                                            end else  \n                                                j <= j + 1 ; \n                                        end else begin  \n                                            countA <= \ncountA + 1;  \n                                        end \n                                    end              \n                            end \n    if (pk_rst && nttinv_count == 3) begin         \n        pkencode_rho <= shakeOut[255:0];  \n \n50          pkencode_t1 <= power_t1;  \n    end  \n            if (pk_rst && nttinv_count == 4) \nbegin  \n    pk_rst <= 0;  \n    nttinv_count <= nttinv_count;  \nend else if (j == 7 && countA == 257) begin  \n    if (pk_rst === 'x) begin  // First clock  \n        pk_rst <= 1;  \n        nttinv_count <= nttinv_count + 1;  \n    end  \n    if (pk_rst == 1) begin // Second clock  \n        pk_rst <= 1;  \n        nttinv_count <= nttinv_count + 1;  \n    end \nend \n \nif (pk_done && shakeRst === 'x) begin  \n     \n    shakeRst <= 1;  \nend \nif (shakeRst) begin  \n    shakeRst <= 0;  \n    shakeIn2 <= pk;  \nend \nif (pk_done && s hakeRst == 0) begin  \n    shakeStart <= 1;  \nend \nif (shakeDone2 && sk_rst === 'x) begin  \n    sk_rst <= 1;  \n    sk_t0 <= power_t0;  \n    for (int i = 0; i < k; i++) begin  \n      $write(\"sk_t0[%0d]: \", i);  \n      for (int j = 0; j < 256; j++) begin  \n        $write(\"%0d  \", power_t0[i][j]);  \n      end \n      $write(\" \\n\"); \n    end end else if (sk_rst) begin  \n    sk_rst <= 0;      \nend \n        end \n    end \n \n    sponge #(  \n        .msg_len(276),  \n        .d_len(1024),  \n        .capacity(512)  \n    ) shake256 (  \n        .clk(clk),  \n        .reset(rst),  \n        .start(1'b1),  \n        .message({4'b1111, shakeIn}),  \n        .z(shakeOut),  \n        .done(shakeDone)  \n    ); \n \n    ExpandA expandA (  \n        .clk(clk),  \n        .rst(expandA_rst),  \n        .start(shakeDone),  \n        .rho(shakeOut[255:0]),  \n        .A(A),  \n        .done(expanda_done)  \n    ); \n \n    ExpandS ExpandS (  \n        .clk(clk),  \n        .rst(expandA_rst),  \n        .start(shakeDone),  \n        .rho(shakeOut[767:256]),  \n        .s1(s1),  \n        .s2(s2),  \n        .done(expands_done)  \n    ); \n \n \n51      NTT #(.WIDTH(64)) NTT (  \n        .clk(clk),  \n        .rst(ntt_module_rst),  \n        .w(w),  \n        .w_hat(w_hat),  \n        .done(nttdone),  \n        .disabler(ntt_disabler)  \n    ); \n     \n    NTT_INV #(.WIDTH(64)) NTT_INV (  \n        .clk(clk),  \n        .rst(nttinv_rst ), \n        .w(nttinv_w),  \n        .w_hat(nttinv_w_hat),  \n        .done(nttinv_done)  \n    ); \n     \n    Power2round #(  \n            .T_WIDTH(64)  \n        ) uut (  \n            .t(power2round_t),  \n            .t1(power2round_t1),  \n            .t0(power2round_t0)  \n        ); \n         \n    PkEncode PkEncode (  \n                .clk(clk),  \n                .reset(pk_rst),  \n                .rho(pkencode_rho),  \n                .t1(pkencode_t1),  \n                .pk(pk),  \n                .valid(pk_done)  \n            );             \n    sponge #(  \n                    .msg_len(20740),  \n                    .d_len(512),  \n                    .capacity(512)  \n                ) shake256_compute_tr (  \n                    .clk(clk),  \n                    .reset(shakeRst),  \n                    .start( shakeStart),  \n                    .message({4'b1111, shakeIn2}),  \n                    .z(shakeOut2),  \n                    .done(shakeDone2)  \n                ); \nskEncode #(  \n                          \n                        .cols_l(l),  \n                        .rows_k(k),  \n                        .n(eta),  \n                        .d(d)  \n                    ) dut (  \n                    .clk(clk),  \n                    .rst(sk_rst),  \n                        .rho(shakeOut[255:0]),  \n                        .K(shakeOut[1023:76 8]), \n                        .tr(shakeOut2),  \n                        .s1(s1),  \n                        .s2(s2),  \n                        .t0(sk_t0),  \n                        .sk(sk),  \n                        .done(final_done)  \n                    );                 \nendmodule  \n \n \n52  \n  \n7.2."
    ]
  },
  {
    "question": "What component diagram shows the modular architecture of the Athestia system?",
    "answer": "The following",
    "supporting_passages": [
      "Component  Diagram  \nThe following component diagram presents the modular architecture of the Athestia system,  \nhighlighting  the integration  of post-quantum  cryptography  using  CRYSTALS - Dilithium within a \nNamed Data Networking (NDN) framework. Figure  7.1 Component  Diagram  of Athestia\n\n53  \n Figure 7.1 illustrates that the architecture is split across thre e core domains: the NDN Emulator, the \nDilithium cryptographic hardware system, and the UART -based communication interface that links \nthem. On the NDN side, the emulator replicates a complete NDN -based communication model. The \nCertificate Authority component is responsible for generating the root public -private key pair and \nsigning the producer\u2019s public key to enable trust -based communication. The Producer  Site includes  \nmodules  to generate  its own key pair (using the hardware engine), sign the data p ackets with the \nprivate key, and produce NDN - compliant data packets. These packets are then sent through the \nNDN Router, which mimics real -world routing of interest and data packets. The Consumer Site \nhandles incoming  data,  starting  with sending  an Intere st packet and  later verifying  the received data \nusing the producer\u2019s public key and the Dilithium Verify module."
    ]
  },
  {
    "question": "What is the main component of the Athestia system?",
    "answer": "NDN Emulator",
    "supporting_passages": [
      "Component  Diagram  \nThe following component diagram presents the modular architecture of the Athestia system,  \nhighlighting  the integration  of post-quantum  cryptography  using  CRYSTALS - Dilithium within a \nNamed Data Networking (NDN) framework. Figure  7.1 Component  Diagram  of Athestia\n\n53  \n Figure 7.1 illustrates that the architecture is split across thre e core domains: the NDN Emulator, the \nDilithium cryptographic hardware system, and the UART -based communication interface that links \nthem. On the NDN side, the emulator replicates a complete NDN -based communication model. The \nCertificate Authority component is responsible for generating the root public -private key pair and \nsigning the producer\u2019s public key to enable trust -based communication. The Producer  Site includes  \nmodules  to generate  its own key pair (using the hardware engine), sign the data p ackets with the \nprivate key, and produce NDN - compliant data packets. These packets are then sent through the \nNDN Router, which mimics real -world routing of interest and data packets. The Consumer Site \nhandles incoming  data,  starting  with sending  an Intere st packet and  later verifying  the received data \nusing the producer\u2019s public key and the Dilithium Verify module."
    ]
  },
  {
    "question": "What is the core cryptographic hardware engine deployed on the FPGA?",
    "answer": "Dilithium Key Module for key generation",
    "supporting_passages": [
      "The Athestia block in the bottom -left corner shows the core cryptographic hardware engine deployed \non FPGA. It includes three separate modules:  the Dilithium Key Module for key generation, the \nDilithium Signature Module for signing packets, and the Dilithium  Verify  Module for checking the \nauthenticity  of incoming content. These modules are designed in SystemVerilog and implement \nalgorithms aligne d with the Dilithium specification. They are optimized to be lightweight and \nefficient, ensuring real -time performance. The UART Driver serves as the communication bridge between the Python frontend and the FPGA \nbackend. It handles hardware -to-software int erfacing and allows the main GUI program to send \nspecific commands to the hardware such as \u201cGenerate Keys\u201d, \u201cSign\u201d, or \u201cVerify\u201d. In response, the \nUART driver receives cryptographic results, such  as the public key, signed data, or verification  \noutcomes, and  passes them back to the frontend for further use in the NDN simulation. The overall data flow begins with the generation of keys on the hardware, which are then utilized by \nthe Producer component to sign data. These signed packets are sent over  the NDN  network,  received  \nby the Consumer,  and finally  verified  using  the public key."
    ]
  },
  {
    "question": "What is the core cryptographic hardware engine deployed on FPGA?",
    "answer": "Dilithium Key Module for key generation",
    "supporting_passages": [
      "The Athestia block in the bottom -left corner shows the core cryptographic hardware engine deployed \non FPGA. It includes three separate modules:  the Dilithium Key Module for key generation, the \nDilithium Signature Module for signing packets, and the Dilithium  Verify  Module for checking the \nauthenticity  of incoming content. These modules are designed in SystemVerilog and implement \nalgorithms aligne d with the Dilithium specification. They are optimized to be lightweight and \nefficient, ensuring real -time performance. The UART Driver serves as the communication bridge between the Python frontend and the FPGA \nbackend. It handles hardware -to-software int erfacing and allows the main GUI program to send \nspecific commands to the hardware such as \u201cGenerate Keys\u201d, \u201cSign\u201d, or \u201cVerify\u201d. In response, the \nUART driver receives cryptographic results, such  as the public key, signed data, or verification  \noutcomes, and  passes them back to the frontend for further use in the NDN simulation. The overall data flow begins with the generation of keys on the hardware, which are then utilized by \nthe Producer component to sign data. These signed packets are sent over  the NDN  network,  received  \nby the Consumer,  and finally  verified  using  the public key."
    ]
  },
  {
    "question": "What is the software stack responsible for packet formatting and routing on the Athestia system?",
    "answer": "\noffloaded  to the hardware  module",
    "supporting_passages": [
      "All  these  cryptographic  operations  are \noffloaded  to the hardware  module,  with the software  stack  handling  packet  formatting  and routing. This structure  demonstrates  a secure, lightweight, and modular architecture capable of  resisting \nquantum -era threats in a named data networking context. 54  \n 7.3 Deployment  Diagram  \n \nFigure  7.3 Deployment  Diagram  \n \nFigure 7.3 represents the physical architecture of the Athestia system, depicting how  different  \nsoftware  and hardware  artifacts  are distributed  across  two main  environments: the FPGA platform and \nthe NDN Emulator on a host machine. On the Dilithium  side, the system  includes  four key compiled  artifacts  (`.bit`  files),  each responsible \nfor a  specific cryptographic operation. The Key Module handles the generation  of public -private key  \npairs based on  the Dilithium  post-quantum  algorithm. The Signature Module is responsible for \nsigning data using the generated private key, while the Verify Module performs signature validation \nusing the public key. Additionally, a UART protocol module is deployed to manage serial \ncommunication between the FPGA and the host machine. These hardware components are written in \nSystemVerilog  and are synthesized  into `.bit`  files before  being  deployed  on the FPGA. The interface  file.c  acts as the communication  bridge  between  the FPGA  hardware  and the  NDN  \nEmulator  software."
    ]
  },
  {
    "question": "What is the software stack responsible for packet formatting and routing?",
    "answer": "\noffloaded  to the hardware  module",
    "supporting_passages": [
      "All  these  cryptographic  operations  are \noffloaded  to the hardware  module,  with the software  stack  handling  packet  formatting  and routing. This structure  demonstrates  a secure, lightweight, and modular architecture capable of  resisting \nquantum -era threats in a named data networking context. 54  \n 7.3 Deployment  Diagram  \n \nFigure  7.3 Deployment  Diagram  \n \nFigure 7.3 represents the physical architecture of the Athestia system, depicting how  different  \nsoftware  and hardware  artifacts  are distributed  across  two main  environments: the FPGA platform and \nthe NDN Emulator on a host machine. On the Dilithium  side, the system  includes  four key compiled  artifacts  (`.bit`  files),  each responsible \nfor a  specific cryptographic operation. The Key Module handles the generation  of public -private key  \npairs based on  the Dilithium  post-quantum  algorithm. The Signature Module is responsible for \nsigning data using the generated private key, while the Verify Module performs signature validation \nusing the public key. Additionally, a UART protocol module is deployed to manage serial \ncommunication between the FPGA and the host machine. These hardware components are written in \nSystemVerilog  and are synthesized  into `.bit`  files before  being  deployed  on the FPGA. The interface  file.c  acts as the communication  bridge  between  the FPGA  hardware  and the  NDN  \nEmulator  software."
    ]
  },
  {
    "question": "What are the core components of a Named Data Networking environment?",
    "answer": "the NDN  Router",
    "supporting_passages": [
      "This C file handles  sending  commands  and receiving  data through the UART \nprotocol, providing a well-defined hardware -software interface. It ensures that operations such as key \ngeneration, signing, and verification can be triggered from the software environment and executed on \nthe hardware. On the NDN Emulator side, the system ru ns the core components of a Named Data Networking  \nenvironment. This includes  the NDN  Router,  which  routes  interest  and data packets  between  nodes,\n\n55  \n the Certificate  Authority,  which  signs  and distributes  producer certificates, the Producer, which \ngenerates and signs data packets, and the Consumer, which sends interest packets and verifies \nreceived data. These components are implemented in Python, and it interacts with the C interface to \ncontrol the FPGA. This deployment  setup  ensures  that all cryptographic  operations  are offloaded  to secure, tamper -\nresistant hardware, while the flexible NDN logic and user interaction are managed in the software \ndomain. This separation of concerns improves both system security and performance. 56  \n 8. Testing  \n \nThis chapter presents a comprehensive evaluation of the Dilithium hardware implementation \nintegrated with  the Named Data Networking (NDN) architecture. The implementation was \nthoroughly tested for correctness, and compliance with the FIPS 204 standard for post-quantum  \ndigital signatures."
    ]
  },
  {
    "question": "What is the core component of a Named Data Networking environment?",
    "answer": "NDN Emulator",
    "supporting_passages": [
      "This C file handles  sending  commands  and receiving  data through the UART \nprotocol, providing a well-defined hardware -software interface. It ensures that operations such as key \ngeneration, signing, and verification can be triggered from the software environment and executed on \nthe hardware. On the NDN Emulator side, the system ru ns the core components of a Named Data Networking  \nenvironment. This includes  the NDN  Router,  which  routes  interest  and data packets  between  nodes,\n\n55  \n the Certificate  Authority,  which  signs  and distributes  producer certificates, the Producer, which \ngenerates and signs data packets, and the Consumer, which sends interest packets and verifies \nreceived data. These components are implemented in Python, and it interacts with the C interface to \ncontrol the FPGA. This deployment  setup  ensures  that all cryptographic  operations  are offloaded  to secure, tamper -\nresistant hardware, while the flexible NDN logic and user interaction are managed in the software \ndomain. This separation of concerns improves both system security and performance. 56  \n 8. Testing  \n \nThis chapter presents a comprehensive evaluation of the Dilithium hardware implementation \nintegrated with  the Named Data Networking (NDN) architecture. The implementation was \nthoroughly tested for correctness, and compliance with the FIPS 204 standard for post-quantum  \ndigital signatures."
    ]
  },
  {
    "question": "What were the two primary testing methodologies used?",
    "answer": "white -box testing  \n\u25cf black -box testing",
    "supporting_passages": [
      "The testing strategy includes white - box testing of internal modules, black -box \ntesting of the system\u2019s external interfaces, and system -level simulations conducted within an NDN \nenvironment. A detailed test plan is outlined , followed by results and analysis. Compliance with the FIPS 204 standard (standard for NIST Post -Quantum Cryptography) was \nthoroughly verified using official test cases. Furthermore, the integration  of this cryptographic  \nscheme into  the NDN  protocol  was evaluated  through simulation -based experiments to analyze its \neffects on protocol behavior and overall system performance. 8.1. TESTING  METHODS  \nTo validate the correctness of the Dilithium hardware module integrated with the Named Data \nNetworking (NDN), two primary  testing methodologies were employed:  \n\u25cf white -box testing  \n\u25cf black -box testing  \nThese  complementary  approaches  ensured  thorough  verification  from  both the internal logic and \nexternal behavior perspectives. The aim was to detect design flaws early, verify functional \ncompliance with the FIPS 204 standard, and evaluate system -level behavior under realistic and edge -\ncase scenarios. 8.1.1. White -box testing:  \nWhite -box testing, also known as structural  or glass -box testing, is a thorough testing approach  that \nexamines the internal  workings of  a system."
    ]
  },
  {
    "question": "What are the two primary testing methodologies used?",
    "answer": "white -box testing  \n\u25cf black -box testing",
    "supporting_passages": [
      "The testing strategy includes white - box testing of internal modules, black -box \ntesting of the system\u2019s external interfaces, and system -level simulations conducted within an NDN \nenvironment. A detailed test plan is outlined , followed by results and analysis. Compliance with the FIPS 204 standard (standard for NIST Post -Quantum Cryptography) was \nthoroughly verified using official test cases. Furthermore, the integration  of this cryptographic  \nscheme into  the NDN  protocol  was evaluated  through simulation -based experiments to analyze its \neffects on protocol behavior and overall system performance. 8.1. TESTING  METHODS  \nTo validate the correctness of the Dilithium hardware module integrated with the Named Data \nNetworking (NDN), two primary  testing methodologies were employed:  \n\u25cf white -box testing  \n\u25cf black -box testing  \nThese  complementary  approaches  ensured  thorough  verification  from  both the internal logic and \nexternal behavior perspectives. The aim was to detect design flaws early, verify functional \ncompliance with the FIPS 204 standard, and evaluate system -level behavior under realistic and edge -\ncase scenarios. 8.1.1. White -box testing:  \nWhite -box testing, also known as structural  or glass -box testing, is a thorough testing approach  that \nexamines the internal  workings of  a system."
    ]
  },
  {
    "question": "What was the method used to validate each component against the NIST FIPS 204 specification?",
    "answer": "Dilithium  hardware module",
    "supporting_passages": [
      "For  the Dilithium  hardware module, this method was  \nused to validate each  component against the NIST  FIPS 204 specification. With full access to the \nsource code and system  design, testers were able to rigorously assess the  correctness of individual \nfunctions and logic paths. Key cryptographic operations \u2014such as the Number Theoretic Transform \n(NTT), polynomial  expansion,  and bit-packing \u2014were  tested  to ensure  accurate  and secure  \n57  \n implementation. Modules  like ExpandA,  ExpandS,  RejNTTPoly,  and RejBoundedPoly were \nspecifically  verified to confirm  proper behavior  when  transforming and rejecting polynomials. The testing extended to key handling operations, where modules for encoding and decoding public \nand pri vate keys (PK Encode/Decode and SK Encode/Decode) were validated for secure and \naccurate functionality. These tests ensured that key material was  correctly  packed  and unpacked  \nwithout  compromising  system  security. Additional testing covered auxiliary compo nents like \npolynomial decomposition (Decompose), sampling in the ball (Sample in Ball), and bit -packing of \nhints (Hint Bit Pack), confirming  that all operations  met the performance  and security  requirements. Overall, white -box testing played a critical rol e in verifying the structural integrity and correctness of \nthe Dilithium hardware module. 8.1.1.1."
    ]
  },
  {
    "question": "What was the NIST FIPS 204 specification used for?",
    "answer": "validate each  component",
    "supporting_passages": [
      "For  the Dilithium  hardware module, this method was  \nused to validate each  component against the NIST  FIPS 204 specification. With full access to the \nsource code and system  design, testers were able to rigorously assess the  correctness of individual \nfunctions and logic paths. Key cryptographic operations \u2014such as the Number Theoretic Transform \n(NTT), polynomial  expansion,  and bit-packing \u2014were  tested  to ensure  accurate  and secure  \n57  \n implementation. Modules  like ExpandA,  ExpandS,  RejNTTPoly,  and RejBoundedPoly were \nspecifically  verified to confirm  proper behavior  when  transforming and rejecting polynomials. The testing extended to key handling operations, where modules for encoding and decoding public \nand pri vate keys (PK Encode/Decode and SK Encode/Decode) were validated for secure and \naccurate functionality. These tests ensured that key material was  correctly  packed  and unpacked  \nwithout  compromising  system  security. Additional testing covered auxiliary compo nents like \npolynomial decomposition (Decompose), sampling in the ball (Sample in Ball), and bit -packing of \nhints (Hint Bit Pack), confirming  that all operations  met the performance  and security  requirements. Overall, white -box testing played a critical rol e in verifying the structural integrity and correctness of \nthe Dilithium hardware module. 8.1.1.1."
    ]
  },
  {
    "question": "What type of unit testing was used to test each function or sub-module in isolation?",
    "answer": "Unit testing",
    "supporting_passages": [
      "Unit  Testing  \nUnit testing  was used to test each  function  or sub-module  in isolation. The following table \nsummarizes the unit tests, detailing the input, expected and actual  outputs, and pass/fail status."
    ]
  },
  {
    "question": "What type of testing was used to test each function or sub-module in isolation?",
    "answer": "Unit testing",
    "supporting_passages": [
      "Unit  Testing  \nUnit testing  was used to test each  function  or sub-module  in isolation. The following table \nsummarizes the unit tests, detailing the input, expected and actual  outputs, and pass/fail status."
    ]
  },
  {
    "question": "What does NTT_inverse NTT polynomial Original polynomial Accurate inverse transformati on?",
    "answer": "Bit Unpack",
    "supporting_passages": [
      "Table  8.1.1.1   Unit Testing  \n \nS.No  Test Case Input  Expected \nOutput  Actual \nOutput  PASS/FAIL  \n1 Expand  A rho byte \nstring  Matrix A \nwith 256 \ncoefficients  Matrix A \nwith 256 \ncoefficients  Pass \n2 RejNTTPoly  byte string  polynomial \nwith 256 \ncoefficients  polynomial \nwith 256 \ncoefficients  Pass \n3 Coefficientfro \nmthreebytes  3 bytes  Integer  Integer  Pass \n4 Expand  S rho_prime \nbyte string  vectors of \npolynomial  vectors of \npolynomial  Pass \n5 RejBoundedPol \ny byte string  polynomial \nwith 256  \ncoefficients  polynomial \nwith 256  \ncoefficients  Pass \n6 Coefficientfro \nmhalfbytes  half byte Integer  Integer  Pass \n7 NTT  Polynomial  NTT  \ntransformed \noutput  verified \nwith known \nresults  Pass \n58  \n 8 NTT_inverse  NTT  \npolynomial  Original \npolynomial  Accurate \ninverse \ntransformati \non Pass \n9 Power2round  Integer  a (a1, a0) pair matches  Pass \n10 Pk Encode  rho, t1 \npolynomial  public  key \nbyte string  matches \nstandard  Pass \n11 Simple  Bit \nPack  polynomial  byte string  matches  Pass \n12 Sk Encode  rho,K,tr,s1&s \n2vectors, \nt0vectors  secret key \nbyte string  matches \nstandard  Pass \n13 Bit Pack polynomial  byte string  byte string \nmatches  Pass \n14 Sk Decode  secret key \nbyte string  rho,K,tr,s1 \n&s2vectors, \nt0vectors  matches  Pass \n15 Bit Unpack  byte string  polynomial  polynomial  Pass \n16 Expand  Mask  rho , mu vector  y matches  Pass \n17 High  Bits Integer  r r1 r1 Pass \n18 Decompose  Integer  r (r1, r0) pair matches  Pass \n19 w1 Encode  w1 vectors  byte string  byte string  Pass \n20 Sample  In Ball byte string  polynomial  matchs  Pass \n21 Low Bits Integer  r r0 r0 Pass \n22 Make  Hint z and r \nvectors  hint vectros  hintvectors  Pass \n23 Sig Encode  c polynomial, \nz vectors, h \nvectors  signature \nbyte string  signature \nbyte string  Pass \n24 Hint Bit Pack h vectors  byte string  byte string  Pass \n25 Pk Decode  public  key \nbyte string  rho, t1 \nvectors  rho, t1 \nvectors  Pass \n26 Simple  Bit \nUnpack  byte string  w vectors  matches  Pass \n59  \n 27 Sig Decode  signature \nbyte string  c \npolynomial, \nz vectors, h \nvectors  matches  Pass \n28 Hint Bit \nUnpack  byte string  h vectors  h vectors  Pass \n29 Use Hint h, w\u2019approx \nvectors  w1 prime \nvectors  matches  Pass \n \n \n8.1.1.2."
    ]
  },
  {
    "question": "What does NTT_inverse NTT polynomial Original polynomial Accurate inverse transformati on Pass 7?",
    "answer": "\npolynomial",
    "supporting_passages": [
      "Table  8.1.1.1   Unit Testing  \n \nS.No  Test Case Input  Expected \nOutput  Actual \nOutput  PASS/FAIL  \n1 Expand  A rho byte \nstring  Matrix A \nwith 256 \ncoefficients  Matrix A \nwith 256 \ncoefficients  Pass \n2 RejNTTPoly  byte string  polynomial \nwith 256 \ncoefficients  polynomial \nwith 256 \ncoefficients  Pass \n3 Coefficientfro \nmthreebytes  3 bytes  Integer  Integer  Pass \n4 Expand  S rho_prime \nbyte string  vectors of \npolynomial  vectors of \npolynomial  Pass \n5 RejBoundedPol \ny byte string  polynomial \nwith 256  \ncoefficients  polynomial \nwith 256  \ncoefficients  Pass \n6 Coefficientfro \nmhalfbytes  half byte Integer  Integer  Pass \n7 NTT  Polynomial  NTT  \ntransformed \noutput  verified \nwith known \nresults  Pass \n58  \n 8 NTT_inverse  NTT  \npolynomial  Original \npolynomial  Accurate \ninverse \ntransformati \non Pass \n9 Power2round  Integer  a (a1, a0) pair matches  Pass \n10 Pk Encode  rho, t1 \npolynomial  public  key \nbyte string  matches \nstandard  Pass \n11 Simple  Bit \nPack  polynomial  byte string  matches  Pass \n12 Sk Encode  rho,K,tr,s1&s \n2vectors, \nt0vectors  secret key \nbyte string  matches \nstandard  Pass \n13 Bit Pack polynomial  byte string  byte string \nmatches  Pass \n14 Sk Decode  secret key \nbyte string  rho,K,tr,s1 \n&s2vectors, \nt0vectors  matches  Pass \n15 Bit Unpack  byte string  polynomial  polynomial  Pass \n16 Expand  Mask  rho , mu vector  y matches  Pass \n17 High  Bits Integer  r r1 r1 Pass \n18 Decompose  Integer  r (r1, r0) pair matches  Pass \n19 w1 Encode  w1 vectors  byte string  byte string  Pass \n20 Sample  In Ball byte string  polynomial  matchs  Pass \n21 Low Bits Integer  r r0 r0 Pass \n22 Make  Hint z and r \nvectors  hint vectros  hintvectors  Pass \n23 Sig Encode  c polynomial, \nz vectors, h \nvectors  signature \nbyte string  signature \nbyte string  Pass \n24 Hint Bit Pack h vectors  byte string  byte string  Pass \n25 Pk Decode  public  key \nbyte string  rho, t1 \nvectors  rho, t1 \nvectors  Pass \n26 Simple  Bit \nUnpack  byte string  w vectors  matches  Pass \n59  \n 27 Sig Decode  signature \nbyte string  c \npolynomial, \nz vectors, h \nvectors  matches  Pass \n28 Hint Bit \nUnpack  byte string  h vectors  h vectors  Pass \n29 Use Hint h, w\u2019approx \nvectors  w1 prime \nvectors  matches  Pass \n \n \n8.1.1.2."
    ]
  },
  {
    "question": "What is the name of the integration testing that ensures that independently developed modules work together as expected when integrated?",
    "answer": "Integration  Testing",
    "supporting_passages": [
      "Integration  Testing  \nIntegration testing ensures that independently developed modules work together as expected \nwhen integrated. These tests verified the full cryptographic lifecycle of key generation, signing, \nand signature verification using both reference and dynamically generated inputs. Table  8.1.1.1   Integration  Testing  \n \nS.No  Test Case Input  Expected \nOutput  Actual \nOutput  PASS  \n/FAIL  \n1 Key \nGeneration  Seed, \nparameters  Valid  Key Pair \n(sk, pk)  Match  with \nstandard  Pass \n2 Signature \nGeneration  Message  + sk Valid  signature \nsig Match  with \nstandard  Pass \n3 Signature \nVerification  (pk, message, \nsig) Accept  (Valid)  Output:  1 \n(true)  Pass \n4 Signature \nVerification  (pk, message, \ncorrupted_sig)  Reject (Invalid)  Output:  0 \n(false)  Pass \n60  \n 8.1.1.3."
    ]
  },
  {
    "question": "What is the name of the integration testing that ensures that modules work together as expected when integrated?",
    "answer": "Integration  Testing",
    "supporting_passages": [
      "Integration  Testing  \nIntegration testing ensures that independently developed modules work together as expected \nwhen integrated. These tests verified the full cryptographic lifecycle of key generation, signing, \nand signature verification using both reference and dynamically generated inputs. Table  8.1.1.1   Integration  Testing  \n \nS.No  Test Case Input  Expected \nOutput  Actual \nOutput  PASS  \n/FAIL  \n1 Key \nGeneration  Seed, \nparameters  Valid  Key Pair \n(sk, pk)  Match  with \nstandard  Pass \n2 Signature \nGeneration  Message  + sk Valid  signature \nsig Match  with \nstandard  Pass \n3 Signature \nVerification  (pk, message, \nsig) Accept  (Valid)  Output:  1 \n(true)  Pass \n4 Signature \nVerification  (pk, message, \ncorrupted_sig)  Reject (Invalid)  Output:  0 \n(false)  Pass \n60  \n 8.1.1.3."
    ]
  },
  {
    "question": "What type of testing was conducted to assess the Dilithium hardware module's external behavior without considering its internal structure?",
    "answer": "Black -box testing",
    "supporting_passages": [
      "System  Testing  \n \nTable  8.1.1.1  System  Testing  \n \nSN \nO TEST CASE  INPUT  EXPECTED \nOUTPUT  ACTUAL \nOUTPUT  PASS/ \nFAIL  \n1 NDN Data \nPacket \nSigning  Test Data  packet  + \nPrivate Key  Signed  data \npacket  Packet was \nsigned and \naccepted  by \nNDN node  Pass \n2 NDN  \nSignature \nVerification \nTest Signed  packet  \n+ Public  Key Validity  result \n(authentic or \nnot) Signature \nverified  within \nNDN router  Pass \n3 Unsupported \nSecurity \nLevel \nHandling  Request to \ngenerate  keys \nor sign using \nlevel 2 or 3  System  should \nreject or not \nsupport  level  2 \nand 3 security \nlevels  Level 2 and 3 \noptions not \nimplemented  or \nrejected \nappropriately  Fail \n4 Unsupported \nNIST Test \nCase \nParameters  NIST test \nvector with \nunsupported \nparams (e.g.,  \npreHash  \u2260 \n\"pure\", \ndifferent \ntgId)  System  should \nreject  or report \nunsupported \nparameter set  System fails to \nhandle \nunsupported  test \ncases; \nunsupported \nconfigs not \nprocessed  Fail \n \n8.1.2. Black -box testing  \nBlack -box testing was conducted to assess the Dilithium hardware module's external behavior  \nwithout  considering  its internal  structure. This type of testing  was instrumental in verifying that the \nmodule functioned correctly from the end -user or system integration  perspective."
    ]
  },
  {
    "question": "What type of testing was conducted to assess the Dilithium hardware module's external behavior without considering it's internal structure?",
    "answer": "Black -box testing",
    "supporting_passages": [
      "System  Testing  \n \nTable  8.1.1.1  System  Testing  \n \nSN \nO TEST CASE  INPUT  EXPECTED \nOUTPUT  ACTUAL \nOUTPUT  PASS/ \nFAIL  \n1 NDN Data \nPacket \nSigning  Test Data  packet  + \nPrivate Key  Signed  data \npacket  Packet was \nsigned and \naccepted  by \nNDN node  Pass \n2 NDN  \nSignature \nVerification \nTest Signed  packet  \n+ Public  Key Validity  result \n(authentic or \nnot) Signature \nverified  within \nNDN router  Pass \n3 Unsupported \nSecurity \nLevel \nHandling  Request to \ngenerate  keys \nor sign using \nlevel 2 or 3  System  should \nreject or not \nsupport  level  2 \nand 3 security \nlevels  Level 2 and 3 \noptions not \nimplemented  or \nrejected \nappropriately  Fail \n4 Unsupported \nNIST Test \nCase \nParameters  NIST test \nvector with \nunsupported \nparams (e.g.,  \npreHash  \u2260 \n\"pure\", \ndifferent \ntgId)  System  should \nreject  or report \nunsupported \nparameter set  System fails to \nhandle \nunsupported  test \ncases; \nunsupported \nconfigs not \nprocessed  Fail \n \n8.1.2. Black -box testing  \nBlack -box testing was conducted to assess the Dilithium hardware module's external behavior  \nwithout  considering  its internal  structure. This type of testing  was instrumental in verifying that the \nmodule functioned correctly from the end -user or system integration  perspective."
    ]
  },
  {
    "question": "What was the goal of the Key Generation Test?",
    "answer": "to \nvalidate the overall behavior",
    "supporting_passages": [
      "The goal  was to \nvalidate the overall behavior, conformance to the NIST FIPS 204 standard, and integrate with \nexternal systems such as the Named Data  Networking  (NDN). The testing  focused  on the input - \noutput  relationship  of key cryptographic o perations like key generation, signature generation, and \nsignature verification. 61  \n The Key Generation Test validated  the correctness  of the generated key  pairs. Public and private \nkeys were generated by the hardware module and then subje cted to statistical and structural checks to \nensure they adhered to the constraints set by the Dilithium specification. These checks included \nconfirming proper polynomial size, randomness of coefficients, and proper encoding formats. This \ntest was critical  in confirming  that the hardware  could  consistently  produce  secure  key material  usable  \nfor subsequent signature operations. The Signature Generation and  Verification Tests were used  to verify  the functional correctness  of \ndigital  signing  and authentication  workflows. Known  test messages  were signed  using  the generated  \nprivate  key, and the resulting  signatures  were  verified  using the  corresponding  public  key. These  \noperations  were  performed  across  various  message sizes  and key instances  to ensure  repeatability  and \nreliability."
    ]
  },
  {
    "question": "The Key Generation Test validated the correctness of the generated key pairs?",
    "answer": "61",
    "supporting_passages": [
      "The goal  was to \nvalidate the overall behavior, conformance to the NIST FIPS 204 standard, and integrate with \nexternal systems such as the Named Data  Networking  (NDN). The testing  focused  on the input - \noutput  relationship  of key cryptographic o perations like key generation, signature generation, and \nsignature verification. 61  \n The Key Generation Test validated  the correctness  of the generated key  pairs. Public and private \nkeys were generated by the hardware module and then subje cted to statistical and structural checks to \nensure they adhered to the constraints set by the Dilithium specification. These checks included \nconfirming proper polynomial size, randomness of coefficients, and proper encoding formats. This \ntest was critical  in confirming  that the hardware  could  consistently  produce  secure  key material  usable  \nfor subsequent signature operations. The Signature Generation and  Verification Tests were used  to verify  the functional correctness  of \ndigital  signing  and authentication  workflows. Known  test messages  were signed  using  the generated  \nprivate  key, and the resulting  signatures  were  verified  using the  corresponding  public  key. These  \noperations  were  performed  across  various  message sizes  and key instances  to ensure  repeatability  and \nreliability."
    ]
  },
  {
    "question": "What did the NDN Integration Test ensure that only correctly signed messages were accepted during verification?",
    "answer": "the test cases",
    "supporting_passages": [
      "Importantly,  the test cases ensured that only correctly signed messages were accepted \nduring verification, and invalid or tampered messages were properly rejected, thereby validating the \nintegrity of the cryptographic logic i n the hardware implementation. The NDN Integration Test extended the scope of functional testing to assess interoperability with \nthe NDN framework. The test ensured that data packets signed with  Dilithium  could  be embedded \ninto NDN  interest and  data packets  and transmitted through  the NDN network. Signature verification \nwas performed at the consumer side to validate the authenticity of the content. This integration \nscenario simulated real - world data flow, validating both performance and security unde r network \nconditions. The success of this test confirmed that the hardware module not only functioned correctly \nin isolation but also integrated seamlessly into a secure NDN -based communication system."
    ]
  },
  {
    "question": "What did the NDN Integration Test ensure that only correctly signed messages were accepted?",
    "answer": "verification",
    "supporting_passages": [
      "Importantly,  the test cases ensured that only correctly signed messages were accepted \nduring verification, and invalid or tampered messages were properly rejected, thereby validating the \nintegrity of the cryptographic logic i n the hardware implementation. The NDN Integration Test extended the scope of functional testing to assess interoperability with \nthe NDN framework. The test ensured that data packets signed with  Dilithium  could  be embedded \ninto NDN  interest and  data packets  and transmitted through  the NDN network. Signature verification \nwas performed at the consumer side to validate the authenticity of the content. This integration \nscenario simulated real - world data flow, validating both performance and security unde r network \nconditions. The success of this test confirmed that the hardware module not only functioned correctly \nin isolation but also integrated seamlessly into a secure NDN -based communication system."
    ]
  },
  {
    "question": "What is the name of the SNO Test Case?",
    "answer": "\nSNO",
    "supporting_passages": [
      "Table  8.1.2  Black -box testing  \n \nSNO  Test Case \nDescription  Input  Expected \nOutput  Actual \nOutput  Status  \n1 Validate \nDilithium \nKey Pair in \nNDN  Public  and \nPrivate \nKeys  from \nhardware  Keys \naccepted  by \nNDN  Keys \nsuccessfully \nintegrated  PASS  \n2 Sign NDN \nData  Packet \nwith \nHardware \nKey Data  Packet  \n+ Hardware \nPrivate  Key Signed  data \npacket  Packet  signed \ncorrectly  PASS  \n62  \n 3 Verify \nSignature  at \nConsumer \nNode  Signed \nPacket + \nHardware \nPublic  Key \nof CA  Signature \nverified  Verified \nsuccessfully \nat consumer  PASS  \n4 Reject \nSignature \nwith \nMismatche \nd Public \nKey Signed \nPacket + \nWrong \nPublic  Key Verification \nfailure  Signature \nrejected  as \nexpected  PASS  \n5 End-to-End \nPacket \nTransfer \nwith \nVerification  Signed \nPacket  \u2192 \nNDN  \nForwarding \nPath Consumer \nreceives \nand verifies \nsignature  Round -trip \nsuccessful \nwith valid \nsignature  PASS  \n6 Signature \nFails on \nImproper \nKey Format  Signed \nPacket + \nIncomplete \nPublic  Key Verification \nfailure  Correctly \nfailed due to \nimproper  key \nformat  PASS  \n7 Handling \nMultiple \ncomponents \nin \nAdvanced \nTopology  Topology \nwith >3  \nCAs,  2 \nProducers, \n10 \nConsumers, \nand 10 \nRouters  GUI should \ndisplay and \nprocess  data \nfrom all \ncomponents \ncorrectly  GUI displays \nand processes \nonly 2 \nProducers; \nothers  are not \nshown or \nignored  FAIL  \n63  \n 9."
    ]
  },
  {
    "question": "What is the name of the SNO test case?",
    "answer": "\nSNO",
    "supporting_passages": [
      "Table  8.1.2  Black -box testing  \n \nSNO  Test Case \nDescription  Input  Expected \nOutput  Actual \nOutput  Status  \n1 Validate \nDilithium \nKey Pair in \nNDN  Public  and \nPrivate \nKeys  from \nhardware  Keys \naccepted  by \nNDN  Keys \nsuccessfully \nintegrated  PASS  \n2 Sign NDN \nData  Packet \nwith \nHardware \nKey Data  Packet  \n+ Hardware \nPrivate  Key Signed  data \npacket  Packet  signed \ncorrectly  PASS  \n62  \n 3 Verify \nSignature  at \nConsumer \nNode  Signed \nPacket + \nHardware \nPublic  Key \nof CA  Signature \nverified  Verified \nsuccessfully \nat consumer  PASS  \n4 Reject \nSignature \nwith \nMismatche \nd Public \nKey Signed \nPacket + \nWrong \nPublic  Key Verification \nfailure  Signature \nrejected  as \nexpected  PASS  \n5 End-to-End \nPacket \nTransfer \nwith \nVerification  Signed \nPacket  \u2192 \nNDN  \nForwarding \nPath Consumer \nreceives \nand verifies \nsignature  Round -trip \nsuccessful \nwith valid \nsignature  PASS  \n6 Signature \nFails on \nImproper \nKey Format  Signed \nPacket + \nIncomplete \nPublic  Key Verification \nfailure  Correctly \nfailed due to \nimproper  key \nformat  PASS  \n7 Handling \nMultiple \ncomponents \nin \nAdvanced \nTopology  Topology \nwith >3  \nCAs,  2 \nProducers, \n10 \nConsumers, \nand 10 \nRouters  GUI should \ndisplay and \nprocess  data \nfrom all \ncomponents \ncorrectly  GUI displays \nand processes \nonly 2 \nProducers; \nothers  are not \nshown or \nignored  FAIL  \n63  \n 9."
    ]
  },
  {
    "question": "What was the core objective of Athestia?",
    "answer": "to develop a  practical  and secure framework for digital \ncommunication",
    "supporting_passages": [
      "Discussion  \nThe project titled Athestia addresses a critical emerging challenge in computer networking: securing \ndata in a post -quantum world. As quantum computing becomes more  plausible,  it poses  a significant  \nthreat  to classical  cryptographic  schemes  like RSA and ECC, which underpin most secure digital \ncommunication today. Our solution introduces Dilithium, a lattice -based digital signature algorithm \nselected by NIST for post -quantum  cryptographic  standardization,  integrated  into a Named  Data  \nNetworking (NDN) architecture using a hardware -accelerated FPGA platform. 9.1. Core  Contributions  and Impact  \nThe core  objective of  this project was  to develop a  practical  and secure framework for digital \ncommunication resistant to quantum -based cryptographic attacks. This was achieved by:  \n\uf0b7 Designing and implementing a hardware accelerator for  Dilithium in SystemVerilog, \nensuring fast and reliable key generation, signing, and verification operations. \uf0b7 Creating a communication bridge between the accelerator and the MiniNDN framework via \nthe UART protocol, enabling real -time cryptographic tasks in  simulated NDN environments. \uf0b7 Modifying the self -certifying packet mechanism in NDN to use Dilithium signatures, thereby \nenhancing data integrity and authentication within a decentralized, data -centric architecture. 9.2."
    ]
  },
  {
    "question": "What was the core goal of Athestia?",
    "answer": "to develop a  practical  and secure framework for digital \ncommunication",
    "supporting_passages": [
      "Discussion  \nThe project titled Athestia addresses a critical emerging challenge in computer networking: securing \ndata in a post -quantum world. As quantum computing becomes more  plausible,  it poses  a significant  \nthreat  to classical  cryptographic  schemes  like RSA and ECC, which underpin most secure digital \ncommunication today. Our solution introduces Dilithium, a lattice -based digital signature algorithm \nselected by NIST for post -quantum  cryptographic  standardization,  integrated  into a Named  Data  \nNetworking (NDN) architecture using a hardware -accelerated FPGA platform. 9.1. Core  Contributions  and Impact  \nThe core  objective of  this project was  to develop a  practical  and secure framework for digital \ncommunication resistant to quantum -based cryptographic attacks. This was achieved by:  \n\uf0b7 Designing and implementing a hardware accelerator for  Dilithium in SystemVerilog, \nensuring fast and reliable key generation, signing, and verification operations. \uf0b7 Creating a communication bridge between the accelerator and the MiniNDN framework via \nthe UART protocol, enabling real -time cryptographic tasks in  simulated NDN environments. \uf0b7 Modifying the self -certifying packet mechanism in NDN to use Dilithium signatures, thereby \nenhancing data integrity and authentication within a decentralized, data -centric architecture. 9.2."
    ]
  },
  {
    "question": "How did the Dilithium accelerator perform in real-world NDN traffic?",
    "answer": "generate \nkeys, sign messages, and verify signatures with notable speed",
    "supporting_passages": [
      "Technical  Feasibility  and Evaluation  \nOur implementation proved that deploying lattice -based cryptography on hardware is not  only \nfeasible  but also efficient  when  carefully  optimized. The Dilithium  accelerator was able to generate \nkeys, sign messages, and verify signatures with notable speed c ompared  to software -only methods. Integration  with MiniNDN  allowed  the simulation of real -world NDN traffic, demonstrating how \nsecure, quantum -resistant communications can be established and maintained. The performance of the accelerator was evaluated agai nst the FIPS 204 test vectors, ensuring  \nconformance  to recognized  cryptographic  standards. Additionally,  our testbench supported white -\nbox and black -box testing, helping verify individual modules (e.g., ExpandA, NTT, Decompose) as \nwell as the entire pipeline. 9.3. System  Integration  and Interoperability  \nA critical part of this project was ensuring seamless interoperability between the Python -based  \nMiniNDN  simulation  and the SystemVerilog -based  hardware  core. This required careful  attention to \ntiming, buff ering, and formatting of messages exchanged over UART. Moreover, since NDN  \n \n64  \n fundamentally differs from traditional IP -based models \u2014prioritizing data over location, special \neffort was required to preserve the semantics of self -certifying packets using Dili thium."
    ]
  },
  {
    "question": "How was the Dilithium accelerator evaluated?",
    "answer": "FIPS 204 test vectors",
    "supporting_passages": [
      "Technical  Feasibility  and Evaluation  \nOur implementation proved that deploying lattice -based cryptography on hardware is not  only \nfeasible  but also efficient  when  carefully  optimized. The Dilithium  accelerator was able to generate \nkeys, sign messages, and verify signatures with notable speed c ompared  to software -only methods. Integration  with MiniNDN  allowed  the simulation of real -world NDN traffic, demonstrating how \nsecure, quantum -resistant communications can be established and maintained. The performance of the accelerator was evaluated agai nst the FIPS 204 test vectors, ensuring  \nconformance  to recognized  cryptographic  standards. Additionally,  our testbench supported white -\nbox and black -box testing, helping verify individual modules (e.g., ExpandA, NTT, Decompose) as \nwell as the entire pipeline. 9.3. System  Integration  and Interoperability  \nA critical part of this project was ensuring seamless interoperability between the Python -based  \nMiniNDN  simulation  and the SystemVerilog -based  hardware  core. This required careful  attention to \ntiming, buff ering, and formatting of messages exchanged over UART. Moreover, since NDN  \n \n64  \n fundamentally differs from traditional IP -based models \u2014prioritizing data over location, special \neffort was required to preserve the semantics of self -certifying packets using Dili thium."
    ]
  },
  {
    "question": "What was one of the challenges faced by MiniNDN?",
    "answer": "successful execution of our design goals",
    "supporting_passages": [
      "The certificate  authority  (CA)  module  was also emulated  in the MiniNDN  environment, responsible \nfor certifying producer public keys. Consumers then validated incoming data  using  the producer's  \ncertificate  and signature,  ensuring  a complete  trust chain \u2014all simulated securely using the custom \ncryptographic accelerator. 9.4. Challenges  Faced  \nDespite the successful execution of our design goals, we encountered several challenges:  \n\uf0b7 Resource  Constraints  on FPGA:  Lattice -based  algorithms  require  polynomial arithmetic, \nmodular reductions, and transformations like NTT, which are resource -intensive. Optimizing \nmemory usage and computation pipeline was critical. \uf0b7 Bit-Level Debugging: Debugging SystemVerilog modules dealing with polynomial bit -\npacking ( e.g., skEncode) was particularly tedious and required GTKWave traces and formal \nverification of intermediate states. \uf0b7 Integration Complexity: Ensuring the correct handshake, timing, and synchronization  \nbetween  software  modules  (Python)  and hardware  logic  proved to be more intricate than \ninitially anticipated. 65  \n 10. Conclusion  \nThe rapid evolution of quantum computing represents both a technological milestone and a critical \nchallenge to current digital security paradigms. Classical cryptographic algorithms,  once  considered  \nunbreakable,  are now at significant  risk due to advances in quantum algorithms such as Shor\u2019s and \nGrover\u2019s."
    ]
  },
  {
    "question": "What was one of the challenges facing MiniNDN?",
    "answer": "successful execution of our design goals",
    "supporting_passages": [
      "The certificate  authority  (CA)  module  was also emulated  in the MiniNDN  environment, responsible \nfor certifying producer public keys. Consumers then validated incoming data  using  the producer's  \ncertificate  and signature,  ensuring  a complete  trust chain \u2014all simulated securely using the custom \ncryptographic accelerator. 9.4. Challenges  Faced  \nDespite the successful execution of our design goals, we encountered several challenges:  \n\uf0b7 Resource  Constraints  on FPGA:  Lattice -based  algorithms  require  polynomial arithmetic, \nmodular reductions, and transformations like NTT, which are resource -intensive. Optimizing \nmemory usage and computation pipeline was critical. \uf0b7 Bit-Level Debugging: Debugging SystemVerilog modules dealing with polynomial bit -\npacking ( e.g., skEncode) was particularly tedious and required GTKWave traces and formal \nverification of intermediate states. \uf0b7 Integration Complexity: Ensuring the correct handshake, timing, and synchronization  \nbetween  software  modules  (Python)  and hardware  logic  proved to be more intricate than \ninitially anticipated. 65  \n 10. Conclusion  \nThe rapid evolution of quantum computing represents both a technological milestone and a critical \nchallenge to current digital security paradigms. Classical cryptographic algorithms,  once  considered  \nunbreakable,  are now at significant  risk due to advances in quantum algorithms such as Shor\u2019s and \nGrover\u2019s."
    ]
  },
  {
    "question": "Athestia: A Clean Slate Application uses Named Data Networking with Dilithium?",
    "answer": "\nNetworking",
    "supporting_passages": [
      "Against this backdrop, our project, Athestia: A Clean Slate Application using Named Data \nNetworking (NDN) with Dilithium, serves as a timely and vital exploration into future -proofing \ndigital communication infrastructures. This project successfully demonstrates the integration of post -quantum cryptographic techniques, \nspecifically the Dilithium digital signatu re scheme, into a Named Data Networking  architecture  via \nthe UART  communication  protocol. It provides  a working prototype  that combines  software  and \nhardware  domains  to address  real-world  concerns around data integrity, authentication, and quantum \nresistance. The decision to implement the Dilithium  algorithm  in hardware using SystemVerilog and \ndeploy  it on an FPGA platform not only enhanced the speed and security of cryptographic operations \nbut also provided practical insights into the performance a nd design trade - offs inherent to hardware -\nbased cryptographic accelerators. Importantly, Athestia is designed to be modular and extensible, enabling future researchers to build \nupon it. The hardware accelerator can be adapted for other post - quantum algor ithms; the \ncommunication interface can be replaced with higher - throughput protocols; and the simulated NDN \nenvironment can be scaled to more complex, realistic topologies."
    ]
  },
  {
    "question": "Athestia: A Clean Slate Application uses Named Data Networking (NDN) with Dilithium?",
    "answer": "\nNetworking",
    "supporting_passages": [
      "Against this backdrop, our project, Athestia: A Clean Slate Application using Named Data \nNetworking (NDN) with Dilithium, serves as a timely and vital exploration into future -proofing \ndigital communication infrastructures. This project successfully demonstrates the integration of post -quantum cryptographic techniques, \nspecifically the Dilithium digital signatu re scheme, into a Named Data Networking  architecture  via \nthe UART  communication  protocol. It provides  a working prototype  that combines  software  and \nhardware  domains  to address  real-world  concerns around data integrity, authentication, and quantum \nresistance. The decision to implement the Dilithium  algorithm  in hardware using SystemVerilog and \ndeploy  it on an FPGA platform not only enhanced the speed and security of cryptographic operations \nbut also provided practical insights into the performance a nd design trade - offs inherent to hardware -\nbased cryptographic accelerators. Importantly, Athestia is designed to be modular and extensible, enabling future researchers to build \nupon it. The hardware accelerator can be adapted for other post - quantum algor ithms; the \ncommunication interface can be replaced with higher - throughput protocols; and the simulated NDN \nenvironment can be scaled to more complex, realistic topologies."
    ]
  },
  {
    "question": "What is Athestia's next goal?",
    "answer": "to integrate Kyber",
    "supporting_passages": [
      "To conclude, this project has proven  the feasibility and practicality  of implementi ng a quantum -\nresistant, hardware -accelerated cryptographic solution in a next -generation networking framework. It \nprovides a strong foundation for future research and development in  secure  communications. The \ninsights  gained, and  the system  developed, represent  a significant  contribution  to the field of post-\nquantum  secure  network  design. As quantum  computing becomes a reality, solutions like Athestia \nwill be instrumental in safeguarding the digital world. 66  \n 11. Future  Work  \nWhile Athestia lays a strong foundation for integrating post -quantum cryptographic signatures  into \nNamed  Data  Networking  (NDN),  it also opens  the door for a wide  range of  future  enhancements  and \nresearch  directions. This project focused  on authentication and  data integri ty using  Dilithium,  a post-\nquantum  digital  signature  scheme. However, ensuring confidentiality and secure key exchange is \nequally important in secure communication systems. 11.1. Integration  of Kyber  for Secure  Key Exchange  \nOur next major goal is to integrate Kyber, a lattice -based Key Encapsulation Mechanism (KEM) \nselected by NIST for post -quantum public -key encryption. While Dilithium  provides digital  \nsignatures, Kyber will  enable secure key  establishment and confidential data exchange within NDN \nby encryptin g content or symmetric keys."
    ]
  },
  {
    "question": "What is Athestia's next major goal?",
    "answer": "to integrate Kyber",
    "supporting_passages": [
      "To conclude, this project has proven  the feasibility and practicality  of implementi ng a quantum -\nresistant, hardware -accelerated cryptographic solution in a next -generation networking framework. It \nprovides a strong foundation for future research and development in  secure  communications. The \ninsights  gained, and  the system  developed, represent  a significant  contribution  to the field of post-\nquantum  secure  network  design. As quantum  computing becomes a reality, solutions like Athestia \nwill be instrumental in safeguarding the digital world. 66  \n 11. Future  Work  \nWhile Athestia lays a strong foundation for integrating post -quantum cryptographic signatures  into \nNamed  Data  Networking  (NDN),  it also opens  the door for a wide  range of  future  enhancements  and \nresearch  directions. This project focused  on authentication and  data integri ty using  Dilithium,  a post-\nquantum  digital  signature  scheme. However, ensuring confidentiality and secure key exchange is \nequally important in secure communication systems. 11.1. Integration  of Kyber  for Secure  Key Exchange  \nOur next major goal is to integrate Kyber, a lattice -based Key Encapsulation Mechanism (KEM) \nselected by NIST for post -quantum public -key encryption. While Dilithium  provides digital  \nsignatures, Kyber will  enable secure key  establishment and confidential data exchange within NDN \nby encryptin g content or symmetric keys."
    ]
  },
  {
    "question": "What did the integration of Dilithium and NDN allow?",
    "answer": "secure communication",
    "supporting_passages": [
      "This integration  will allow:  \n\uf0b7 End-to-end encryption  of content  packets  in NDN. \uf0b7 Mutual authentication and secure session setup between producers and consumers. \uf0b7 Deployment  of hybrid  encryption  schemes  using  Kyber  (for key exchange)  and AES (for data \npayload encryption). We plan to implement Kyber\u2019s encapsulation and decapsulation modules in hardware alongside \nDilithium  and explore secure key  negotiation  protocols adapted to  the NDN architecture. 11.2. Real -World  Deployment  and Evaluation  \nWe also plan to deploy  the complete  cryptographic  NDN  system  in a multi -node  testbed  \n\uf0b7 Real-time latency  and throughput. \uf0b7 Packet overhead  introduced by  post-quantum  cryptography. \uf0b7 Scalability  with large  numbers  of producers/consumers. Such experiments will validate the practical viability  of our system  and help optimize parameters for \nfield use. 67  \n 12. Achievement  \nParticipation  in CAMP -V Event  by RISC -V at MERL -UIT \n \n\u25cf Event: CAMP -V (Creative Applications for Microprocessor Platforms - Virtual) \norganized by  the RISC -V community at the MERL (Microelectronics Research Lab) at \nUsman Institute of Technology. \u25cf Experience: Presented  the concept and initial  implementation  of the Dilithium accelerator \nintegrated with the NDN protocol for secure communication. \u25cf Outcome:  \n\u25cb Received valuable feedback from  experts  in microprocessor  design  and post -\nquantum cryptography."
    ]
  },
  {
    "question": "What does the integration of Dilithium and NDN allow?",
    "answer": "secure communication",
    "supporting_passages": [
      "This integration  will allow:  \n\uf0b7 End-to-end encryption  of content  packets  in NDN. \uf0b7 Mutual authentication and secure session setup between producers and consumers. \uf0b7 Deployment  of hybrid  encryption  schemes  using  Kyber  (for key exchange)  and AES (for data \npayload encryption). We plan to implement Kyber\u2019s encapsulation and decapsulation modules in hardware alongside \nDilithium  and explore secure key  negotiation  protocols adapted to  the NDN architecture. 11.2. Real -World  Deployment  and Evaluation  \nWe also plan to deploy  the complete  cryptographic  NDN  system  in a multi -node  testbed  \n\uf0b7 Real-time latency  and throughput. \uf0b7 Packet overhead  introduced by  post-quantum  cryptography. \uf0b7 Scalability  with large  numbers  of producers/consumers. Such experiments will validate the practical viability  of our system  and help optimize parameters for \nfield use. 67  \n 12. Achievement  \nParticipation  in CAMP -V Event  by RISC -V at MERL -UIT \n \n\u25cf Event: CAMP -V (Creative Applications for Microprocessor Platforms - Virtual) \norganized by  the RISC -V community at the MERL (Microelectronics Research Lab) at \nUsman Institute of Technology. \u25cf Experience: Presented  the concept and initial  implementation  of the Dilithium accelerator \nintegrated with the NDN protocol for secure communication. \u25cf Outcome:  \n\u25cb Received valuable feedback from  experts  in microprocessor  design  and post -\nquantum cryptography."
    ]
  },
  {
    "question": "What did the team gain from the RISC -V CAMP -V event?",
    "answer": "insights into further optimizing the accelerator for real -world deployment",
    "supporting_passages": [
      "\u25cb Gained insights into further optimizing the accelerator for real -world deployment. \u25cf Evidence:  \n\u25cb Presentation  slides  and photographs  from  the event. \u25cb Acknowledgment  from  event  organizers  for participation     \n \n68  \n 13. Appendices  \nAnnex  A: Acknowledgements  \n1. Inst it utional  Support  and Event  Participation  \no Usman Institute of Technology  (UIT): We gratefully acknowledge  the support and facilities \nprovided by UIT throughout the development of our Final Year Project. The guidance from \nfaculty members and access to research resources were instrumental in completing our work. o Microelectronics  Research  Lab (MERL -UIT): MERL  provided a collaborative environment \nthat supported hardware experimentation, especially in FPGA - based cryptographic \nimplementations. We appreciate the lab's mentoring and provision of technical resources. o Participation  in RISC -V CAMP -V: Our team  had the opportunity  to present  the project at the \nRISC -V CAMP -V event. This platform enabled us to share our innovation, gather feedback \nfrom experts, and gain valuable exposure to advancements in secure embedded systems and \npost-quantum cryptography. Annex  B: Organization  Overview  \n \n1."
    ]
  },
  {
    "question": "What did the UIT team gain from the RISC -V CAMP -V event?",
    "answer": "exposure to advancements in secure embedded systems and \npost-quantum cryptography",
    "supporting_passages": [
      "\u25cb Gained insights into further optimizing the accelerator for real -world deployment. \u25cf Evidence:  \n\u25cb Presentation  slides  and photographs  from  the event. \u25cb Acknowledgment  from  event  organizers  for participation     \n \n68  \n 13. Appendices  \nAnnex  A: Acknowledgements  \n1. Inst it utional  Support  and Event  Participation  \no Usman Institute of Technology  (UIT): We gratefully acknowledge  the support and facilities \nprovided by UIT throughout the development of our Final Year Project. The guidance from \nfaculty members and access to research resources were instrumental in completing our work. o Microelectronics  Research  Lab (MERL -UIT): MERL  provided a collaborative environment \nthat supported hardware experimentation, especially in FPGA - based cryptographic \nimplementations. We appreciate the lab's mentoring and provision of technical resources. o Participation  in RISC -V CAMP -V: Our team  had the opportunity  to present  the project at the \nRISC -V CAMP -V event. This platform enabled us to share our innovation, gather feedback \nfrom experts, and gain valuable exposure to advancements in secure embedded systems and \npost-quantum cryptography. Annex  B: Organization  Overview  \n \n1."
    ]
  },
  {
    "question": "What is the main focus of the Microelectronics Research Lab at UIT?",
    "answer": "digital hardware design, and microprocessor \narchitectures",
    "supporting_passages": [
      "About  Usman  Institute  of Technology  (UIT) : \n\u25cb Institution  Overview:  \nUsman Institute of Technology (UIT), affiliated with NED University of  Engineering and \nTechnology, is  a leading institution  offering degree programs in computer science, electrical \nengineering, and related disciplines. UIT is committed to fostering academic excellence and \npractical innovation in the field of engineering and technology. \u25cb Vision  and Mission:  \nThe vision of UIT is to produce highly competent professionals equipped to lead in their \nrespective fields. Its mission is to provide quality education and foster an environment \nconducive to learning, research, and innovation. \u25cb Contribution  to Final  Year  Projects:  \nUIT encourages applied research and hands -on projects at the undergraduate level. The \ninstitute provides access to laboratories, faculty mentorship, and resources required for \nstudents to explore emerging technologies such as post -quantum cryptography, embedded \nsystems, and secure communication. 69  \n 2. Microelectronics  Research  Lab (MERL) : \n\u25cb Overview:  \nThe Microelectronics  Research  Lab (MERL) is  a research  group  at UIT focused on \nembedded systems, FPGA development, digital hardware design, and microprocessor \narchitectures. The lab provides both theoretica l and practical exposure to students interested \nin advanced hardware development."
    ]
  },
  {
    "question": "What is the name of the research lab at UIT?",
    "answer": "Microelectronics  Research  Lab",
    "supporting_passages": [
      "About  Usman  Institute  of Technology  (UIT) : \n\u25cb Institution  Overview:  \nUsman Institute of Technology (UIT), affiliated with NED University of  Engineering and \nTechnology, is  a leading institution  offering degree programs in computer science, electrical \nengineering, and related disciplines. UIT is committed to fostering academic excellence and \npractical innovation in the field of engineering and technology. \u25cb Vision  and Mission:  \nThe vision of UIT is to produce highly competent professionals equipped to lead in their \nrespective fields. Its mission is to provide quality education and foster an environment \nconducive to learning, research, and innovation. \u25cb Contribution  to Final  Year  Projects:  \nUIT encourages applied research and hands -on projects at the undergraduate level. The \ninstitute provides access to laboratories, faculty mentorship, and resources required for \nstudents to explore emerging technologies such as post -quantum cryptography, embedded \nsystems, and secure communication. 69  \n 2. Microelectronics  Research  Lab (MERL) : \n\u25cb Overview:  \nThe Microelectronics  Research  Lab (MERL) is  a research  group  at UIT focused on \nembedded systems, FPGA development, digital hardware design, and microprocessor \narchitectures. The lab provides both theoretica l and practical exposure to students interested \nin advanced hardware development."
    ]
  },
  {
    "question": "What did MERL provide technical resources to support the implementation of the Dilithium cryptographic accelerator?",
    "answer": "FPGA boards, simulation software",
    "supporting_passages": [
      "\u25cb Role  in the Project:  \nMERL provided technical resources such as FPGA boards, simulation software, and  expert \nguidance  that supported  the implementation of  the Dilithium cryptographic accelerator. It \nserved as the primary environment for hardware prototyping and testing during the course of \nthe project. Annex  C: Background  and Literature  Review  \n \n1. Key Research  Papers : \n\u25cb \u201cNAC: Name -Based Access Control in Named Data Networking \u201d \u2013 Zhiyi  Zhang  et al. : This \nseminal  paper  explores  a scalable  access  control mechanism within NDN. It inspired our \napproach to secure content naming and policy enforcement in Athestia. \u25cb Lattice -Based Cryptography & Dilithium: We studied the NIST PQC standa rds and multiple \nacademic papers highlighting the resilience of Dilithium against quantum attacks. This \nliterature shaped our algorithmic and architectural decisions. 2. Details  of Similar  Projects : \n\u25cb We reviewed multiple research projects combining PQC with content - centric networking. But to the best of our knowledge, we did not find their integration. Hence we explore some \ndilithium implementations. 3. UML  Diagrams : \n\u25cb Detailed UML diagrams are presented to model  the system\u2019s structure, including the \ninteraction between the NDN routing layer, content signature modules, and the Dilithium \naccelerator."
    ]
  },
  {
    "question": "What did MERL provide to support the implementation of the Dilithium cryptographic accelerator?",
    "answer": "expert \nguidance",
    "supporting_passages": [
      "\u25cb Role  in the Project:  \nMERL provided technical resources such as FPGA boards, simulation software, and  expert \nguidance  that supported  the implementation of  the Dilithium cryptographic accelerator. It \nserved as the primary environment for hardware prototyping and testing during the course of \nthe project. Annex  C: Background  and Literature  Review  \n \n1. Key Research  Papers : \n\u25cb \u201cNAC: Name -Based Access Control in Named Data Networking \u201d \u2013 Zhiyi  Zhang  et al. : This \nseminal  paper  explores  a scalable  access  control mechanism within NDN. It inspired our \napproach to secure content naming and policy enforcement in Athestia. \u25cb Lattice -Based Cryptography & Dilithium: We studied the NIST PQC standa rds and multiple \nacademic papers highlighting the resilience of Dilithium against quantum attacks. This \nliterature shaped our algorithmic and architectural decisions. 2. Details  of Similar  Projects : \n\u25cb We reviewed multiple research projects combining PQC with content - centric networking. But to the best of our knowledge, we did not find their integration. Hence we explore some \ndilithium implementations. 3. UML  Diagrams : \n\u25cb Detailed UML diagrams are presented to model  the system\u2019s structure, including the \ninteraction between the NDN routing layer, content signature modules, and the Dilithium \naccelerator."
    ]
  },
  {
    "question": "What are the key components of the Athestia platform?",
    "answer": "keygen,  signing,  and \nverification",
    "supporting_passages": [
      "70  \n Annex  D: Hardware  and Software  Analysis  \n \n1. Hardware  Specifications : \n\u25cb Arty A7 FPGA Board: Xilinx Artix -7 FPGA with thousands of logic cells, supporting  \nVivado  Design Suite. Suitable for lightweight cryptographic accelerators and interfacing \nwith serial/IP networks. 2. Detailed  Requirements  Document : \n\u25cb Use Case Narrations: We defined key user scenarios, including NDN router behavior when \nhandling signed Interests and  Data packets. \u25cb Functional  & Non-Functional  Requirements:  \n\u25cb Latency  targets  for signing/verification. \u25cb Compatibility  with SHAKE -256 hash functions. Annex  E: Software  Design  and Modeling  \n \n1. Detailed  Design  Documents : \n\u25cb System -Level Architecture: Illustrates the layering of the Athestia platform \u2014from user -\nfacing applications to NDN routers and PQC verification engines. \u25cb Modular FPGA Design: The Dilithium core is split into modules for keygen,  signing,  and \nverification,  each synthesizable  independently  and reusable across projects. \u25cb Flowcharts: We included step -by-step diagrams of data signing/verification for both user \nrequests and content producers. Annex  F: Software  and Hardware  Algorithms  \n \n1. Dilithium  Algorithm  Details : \n\u25cb Pseudocode: Full pseudocode is provided for all three critical phases: KeyGen, Sign, and \nVerify, formatted  in a hardware -friendly manner to aid future HDL translation."
    ]
  },
  {
    "question": "What are the key components of the Athestia core?",
    "answer": "keygen,  signing,  and \nverification",
    "supporting_passages": [
      "70  \n Annex  D: Hardware  and Software  Analysis  \n \n1. Hardware  Specifications : \n\u25cb Arty A7 FPGA Board: Xilinx Artix -7 FPGA with thousands of logic cells, supporting  \nVivado  Design Suite. Suitable for lightweight cryptographic accelerators and interfacing \nwith serial/IP networks. 2. Detailed  Requirements  Document : \n\u25cb Use Case Narrations: We defined key user scenarios, including NDN router behavior when \nhandling signed Interests and  Data packets. \u25cb Functional  & Non-Functional  Requirements:  \n\u25cb Latency  targets  for signing/verification. \u25cb Compatibility  with SHAKE -256 hash functions. Annex  E: Software  Design  and Modeling  \n \n1. Detailed  Design  Documents : \n\u25cb System -Level Architecture: Illustrates the layering of the Athestia platform \u2014from user -\nfacing applications to NDN routers and PQC verification engines. \u25cb Modular FPGA Design: The Dilithium core is split into modules for keygen,  signing,  and \nverification,  each synthesizable  independently  and reusable across projects. \u25cb Flowcharts: We included step -by-step diagrams of data signing/verification for both user \nrequests and content producers. Annex  F: Software  and Hardware  Algorithms  \n \n1. Dilithium  Algorithm  Details : \n\u25cb Pseudocode: Full pseudocode is provided for all three critical phases: KeyGen, Sign, and \nVerify, formatted  in a hardware -friendly manner to aid future HDL translation."
    ]
  },
  {
    "question": "What did the NIST PQC team provide feedback on during the CAMP -V event?",
    "answer": "FPGA  optimization  strategies",
    "supporting_passages": [
      "\u25cb Technical References: Algorithms are aligned with the FIPS 204 standard and the \nCRYSTALS -Dilithium documentation by the NIST PQC team. Annex  G: Achievements  \n \n1. Correspondence : \n\u25cb Mentorship  Notes:  Feedback  from  technical  mentors  during  the CAMP -V event  was also \nrecorded  to help refine  our FPGA  optimization  strategies. 71  \n Annex  H: Plagiarism  Report  \n \n \n \n\n72  \n References  \n \n[1]       National  Institute  of Standards  and Technology, Post -Quantum  Cryptography:  ML-DSA  \n(FIPS  204),  Gaithersburg, MD, USA:  U.S. Department  of Commerce , 2024  \n \n[2] Hidouri, Abdelhak, et al. \"A survey on security attacks and intrusion detection mechanisms \nin named data networking.\" Computers 11.12 (2022): 186. [3] Soni, Deepraj, et al. \"Crystals -dilithium.\" Hardware Architectures for Post - Quantum Digital \nSignature Schemes (2021): 13 -30. [4] Budiana, Mochamad Soebagja, et al. \"Impact of  the Content Store Scaling toward the LRU \nand FIFO Cache Replacements on NDN using Mini -NDN.\" 2021 15th International Conference on \nTelecommunication Systems, Services, and Applications (TSSA). IEEE, 2021. [5] Ma, Xinyu, Alexander Afanasyev, and Lixia Zhang. \"A type -theoretic model on ndn-tlv \nencoding.\" Proceedings of the 9th ACM Conference on Information -Centric Networking. 2022. [6] Yan, Lianglin, Ming Luo, and Mingsheng Wang. \"Speedup signing pre -rejection  sampling  \ntowards  dilithium.\""
    ]
  },
  {
    "question": "What did the NIST PQC team do to help refine our FPGA optimization strategies?",
    "answer": "Mentorship",
    "supporting_passages": [
      "\u25cb Technical References: Algorithms are aligned with the FIPS 204 standard and the \nCRYSTALS -Dilithium documentation by the NIST PQC team. Annex  G: Achievements  \n \n1. Correspondence : \n\u25cb Mentorship  Notes:  Feedback  from  technical  mentors  during  the CAMP -V event  was also \nrecorded  to help refine  our FPGA  optimization  strategies. 71  \n Annex  H: Plagiarism  Report  \n \n \n \n\n72  \n References  \n \n[1]       National  Institute  of Standards  and Technology, Post -Quantum  Cryptography:  ML-DSA  \n(FIPS  204),  Gaithersburg, MD, USA:  U.S. Department  of Commerce , 2024  \n \n[2] Hidouri, Abdelhak, et al. \"A survey on security attacks and intrusion detection mechanisms \nin named data networking.\" Computers 11.12 (2022): 186. [3] Soni, Deepraj, et al. \"Crystals -dilithium.\" Hardware Architectures for Post - Quantum Digital \nSignature Schemes (2021): 13 -30. [4] Budiana, Mochamad Soebagja, et al. \"Impact of  the Content Store Scaling toward the LRU \nand FIFO Cache Replacements on NDN using Mini -NDN.\" 2021 15th International Conference on \nTelecommunication Systems, Services, and Applications (TSSA). IEEE, 2021. [5] Ma, Xinyu, Alexander Afanasyev, and Lixia Zhang. \"A type -theoretic model on ndn-tlv \nencoding.\" Proceedings of the 9th ACM Conference on Information -Centric Networking. 2022. [6] Yan, Lianglin, Ming Luo, and Mingsheng Wang. \"Speedup signing pre -rejection  sampling  \ntowards  dilithium.\""
    ]
  },
  {
    "question": "What is the name of the paper published in Cybersecurity 8.1 (2025): 10?",
    "answer": "An Overview of Security Support in Named Data Networking",
    "supporting_passages": [
      "Cybersecurity  8.1 (2025):  10. [7] Z. Zhang et al., \"An Overview of Security Support in Named Data Networking,\" in  IEEE \nCommunications Magazine, vol. 56, no. 11, pp. 62 -68, November 2018, doi: \n10.1109/MCOM.2018.1701147. [8] Nour,  Boubakr,  et al. \"Access  control  mechanisms  in named  data networks:  A \ncomprehensive survey.\" Acm computing Surveys (cSuR) 54.3 (2021): 1 -35. [9] Nichols,  Kathleen. \"Trust  schemas  and icn: key to secure  home  iot.\" Proceedings  of the 8th \nACM Conference on Information -Centric Networking. 2021. [10] Ricci, Sara, et al. \"Implementing CRYSTALS -Dilithium signature scheme on FPGAs.\" Proceedings  of the 16th  International  Conference on  Availability, Reliability and Security. 2021. 73  \n  \n[11] Truong,  Quang  Dang,  Phap  Ngoc  Duong,  and Hanho  Lee. \"Efficient  Low-Latency Hardware \nArchitecture for Module -Lattice -Based Digital Signature Standard.\" IEEE Access (2024). [12] Land, Georg, Pascal Sasdrich, and Tim G\u00fcneysu. \"A hard crystal -implementing dilithium on \nreconfigurable hardware.\" International Conference on Smart Card Research  and Advanced \nApplicati ons. Cham:  Springer International  Publishing, 2021. [13] Zhao, Cankun, et  al. \"A  compact and  high-performance  hardware  architecture  for \nCRYSTALS -Dilithium.\" IACR Transactions on Cryptographic Hardware and Embedded Systems \n(2022): 270 -295. [14] Aikata, Aikata, et al. \"KaLi: A  crystal  for post -quantum  security  using Kyber and \nDilithium.\""
    ]
  },
  {
    "question": "What is the name of the paper published in Cybersecurity 8.1 (2025)?",
    "answer": "An Overview of Security Support in Named Data Networking",
    "supporting_passages": [
      "Cybersecurity  8.1 (2025):  10. [7] Z. Zhang et al., \"An Overview of Security Support in Named Data Networking,\" in  IEEE \nCommunications Magazine, vol. 56, no. 11, pp. 62 -68, November 2018, doi: \n10.1109/MCOM.2018.1701147. [8] Nour,  Boubakr,  et al. \"Access  control  mechanisms  in named  data networks:  A \ncomprehensive survey.\" Acm computing Surveys (cSuR) 54.3 (2021): 1 -35. [9] Nichols,  Kathleen. \"Trust  schemas  and icn: key to secure  home  iot.\" Proceedings  of the 8th \nACM Conference on Information -Centric Networking. 2021. [10] Ricci, Sara, et al. \"Implementing CRYSTALS -Dilithium signature scheme on FPGAs.\" Proceedings  of the 16th  International  Conference on  Availability, Reliability and Security. 2021. 73  \n  \n[11] Truong,  Quang  Dang,  Phap  Ngoc  Duong,  and Hanho  Lee. \"Efficient  Low-Latency Hardware \nArchitecture for Module -Lattice -Based Digital Signature Standard.\" IEEE Access (2024). [12] Land, Georg, Pascal Sasdrich, and Tim G\u00fcneysu. \"A hard crystal -implementing dilithium on \nreconfigurable hardware.\" International Conference on Smart Card Research  and Advanced \nApplicati ons. Cham:  Springer International  Publishing, 2021. [13] Zhao, Cankun, et  al. \"A  compact and  high-performance  hardware  architecture  for \nCRYSTALS -Dilithium.\" IACR Transactions on Cryptographic Hardware and Embedded Systems \n(2022): 270 -295. [14] Aikata, Aikata, et al. \"KaLi: A  crystal  for post -quantum  security  using Kyber and \nDilithium.\""
    ]
  },
  {
    "question": "What is the name of the IEEE Transactions on Circuits and Systems I regular paper?",
    "answer": "70.2",
    "supporting_passages": [
      "IEEE  Transactions  on Circuits  and Systems  I: Regular  Papers 70.2  (2022): 747-758. [15] Phan, Quoc Bao, et al. \"Enhancing Data Security in Federated Learning with Dilithium.\" 2025 IEEE I nternational Conference on Consumer Electronics (ICCE). IEEE, 2025. [16] Bandara, Harshana, et al. \"On advances of lattice -based cryptographic schemes and their \nimplementations.\" Cryptography 6.4 (2022): 56. [17] Hu, Xiao,  et al. \"AC-PM: An area-efficient  and configurable  polynomial  multiplier for lattice  \nbased  cryptography.\" IEEE  Transactions  on Circuits  and Systems  I: Regular Papers 70.2 (2022): 719 -\n732. [18] Afanasyev, Alexander, Ilya Moiseenko, and Lixia Zhang. \"ndnSIM: NDN simulator for \nNS-3.\" (2012). [19] Yuan, Haowei, Tian Song, and Patrick Crowley. \"Scalable NDN forwarding: Concepts, \nissues and principles.\" 2012 21st International Conference on computer communications and \nnetworks (ICCCN). IEEE, 2012. [20] Mastorakis, Spyridon, Alexander Afanasyev, and  Lixia  Zhang. \"On the evolution of \nndnSIM: An open -source simulator for NDN experimentation.\" ACM SIGCOMM Computer \nCommunication Review 47.3 (2017): 19 -33. Elite Dynamics Partners\nComprehensive Organizational Policies\nEffective Date: January 1, 2024\nVersion: 3.6\nConfidential Document - For Internal Use Only\nThis document contains proprietary information and policies of the organization. Table of Contents\n1. Company Overview\n2. Human Resources Policies\n3."
    ]
  },
  {
    "question": "What is the name of the IEEE Transactions on Circuits and Systems I regular papers?",
    "answer": "70.2",
    "supporting_passages": [
      "IEEE  Transactions  on Circuits  and Systems  I: Regular  Papers 70.2  (2022): 747-758. [15] Phan, Quoc Bao, et al. \"Enhancing Data Security in Federated Learning with Dilithium.\" 2025 IEEE I nternational Conference on Consumer Electronics (ICCE). IEEE, 2025. [16] Bandara, Harshana, et al. \"On advances of lattice -based cryptographic schemes and their \nimplementations.\" Cryptography 6.4 (2022): 56. [17] Hu, Xiao,  et al. \"AC-PM: An area-efficient  and configurable  polynomial  multiplier for lattice  \nbased  cryptography.\" IEEE  Transactions  on Circuits  and Systems  I: Regular Papers 70.2 (2022): 719 -\n732. [18] Afanasyev, Alexander, Ilya Moiseenko, and Lixia Zhang. \"ndnSIM: NDN simulator for \nNS-3.\" (2012). [19] Yuan, Haowei, Tian Song, and Patrick Crowley. \"Scalable NDN forwarding: Concepts, \nissues and principles.\" 2012 21st International Conference on computer communications and \nnetworks (ICCCN). IEEE, 2012. [20] Mastorakis, Spyridon, Alexander Afanasyev, and  Lixia  Zhang. \"On the evolution of \nndnSIM: An open -source simulator for NDN experimentation.\" ACM SIGCOMM Computer \nCommunication Review 47.3 (2017): 19 -33. Elite Dynamics Partners\nComprehensive Organizational Policies\nEffective Date: January 1, 2024\nVersion: 3.6\nConfidential Document - For Internal Use Only\nThis document contains proprietary information and policies of the organization. Table of Contents\n1. Company Overview\n2. Human Resources Policies\n3."
    ]
  },
  {
    "question": "What are the policies and procedures that guide our operations and define our organizational culture?",
    "answer": "Information Technology Policies",
    "supporting_passages": [
      "Information Technology Policies\n4. Code of Conduct\n5. Data Protection & Privacy Policies\n6. Appendices\n1. Company Overview\nElite Dynamics Partners was founded in 2010 and has grown to become a leading \norganization in the Retail & E-commerce sector. With approximately 4250 employees \nworldwide, we are committed to excellence, innovation, and ethical business practices. Our mission is to deliver exceptional value to our clients while maintaining the highest \nstandards of integrity and professionalism. This document outlines the policies and \nprocedures that guide our operations and define our organizational culture. Core Values:\n- Integrity and Ethical Conduct\n- Innovation and Continuous Improvement\n- Customer Focus and Satisfaction\n- Employee Development and Well-being\n- Social Responsibility and Sustainability\nOrganizational Structure:\nThe company operates with a matrix structure that promotes collaboration across \ndepartments while maintaining clear lines of authority and accountability. 2. Human Resources Policies\n2.1 Employment Policies\nAll employment decisions are based on merit, qualifications, and business needs. The organization prohibits discrimination based on race, color, religion, sex, \nnational origin, age, disability, or any other protected status. Probation Period: New employees undergo a 90-day probation period with \nperformance evaluations at 30, 60, and 90 days."
    ]
  },
  {
    "question": "What is the Code of Conduct of Elite Dynamics Partners?",
    "answer": "Information Technology Policies\n",
    "supporting_passages": [
      "Information Technology Policies\n4. Code of Conduct\n5. Data Protection & Privacy Policies\n6. Appendices\n1. Company Overview\nElite Dynamics Partners was founded in 2010 and has grown to become a leading \norganization in the Retail & E-commerce sector. With approximately 4250 employees \nworldwide, we are committed to excellence, innovation, and ethical business practices. Our mission is to deliver exceptional value to our clients while maintaining the highest \nstandards of integrity and professionalism. This document outlines the policies and \nprocedures that guide our operations and define our organizational culture. Core Values:\n- Integrity and Ethical Conduct\n- Innovation and Continuous Improvement\n- Customer Focus and Satisfaction\n- Employee Development and Well-being\n- Social Responsibility and Sustainability\nOrganizational Structure:\nThe company operates with a matrix structure that promotes collaboration across \ndepartments while maintaining clear lines of authority and accountability. 2. Human Resources Policies\n2.1 Employment Policies\nAll employment decisions are based on merit, qualifications, and business needs. The organization prohibits discrimination based on race, color, religion, sex, \nnational origin, age, disability, or any other protected status. Probation Period: New employees undergo a 90-day probation period with \nperformance evaluations at 30, 60, and 90 days."
    ]
  },
  {
    "question": "What is the standard working hours of an employee?",
    "answer": "9:00 AM to 5:00 PM",
    "supporting_passages": [
      "Working Hours: Standard working hours are 9:00 AM to 5:00 PM, Monday through \nFriday, with flexibility arrangements available based on role requirements. 2.2 Compensation and Benefits\nThe organization offers competitive compensation packages including:\n- Base salary reviewed annually\n- Performance-based bonuses\n- Comprehensive health insurance\n- Retirement savings plan with company matching\n- Paid time off and holidays\n- Professional development opportunities\nSalary bands are determined based on market research, role requirements, \nand individual qualifications. 2.3 Leave Policies\nVacation Leave: Employees accrue 15 days annually, increasing with tenure. Sick Leave: 10 days per year with proper documentation. Parental Leave: 12 weeks paid leave for primary caregivers. Emergency Leave: Available for family emergencies with manager approval. All leave requests must be submitted through the HR portal with appropriate \nadvance notice when possible. 3. Information Technology Policies\n3.1 Acceptable Use Policy\nCompany IT resources are provided for business purposes."
    ]
  },
  {
    "question": "What is the standard working hours of the company?",
    "answer": "9:00 AM to 5:00 PM",
    "supporting_passages": [
      "Working Hours: Standard working hours are 9:00 AM to 5:00 PM, Monday through \nFriday, with flexibility arrangements available based on role requirements. 2.2 Compensation and Benefits\nThe organization offers competitive compensation packages including:\n- Base salary reviewed annually\n- Performance-based bonuses\n- Comprehensive health insurance\n- Retirement savings plan with company matching\n- Paid time off and holidays\n- Professional development opportunities\nSalary bands are determined based on market research, role requirements, \nand individual qualifications. 2.3 Leave Policies\nVacation Leave: Employees accrue 15 days annually, increasing with tenure. Sick Leave: 10 days per year with proper documentation. Parental Leave: 12 weeks paid leave for primary caregivers. Emergency Leave: Available for family emergencies with manager approval. All leave requests must be submitted through the HR portal with appropriate \nadvance notice when possible. 3. Information Technology Policies\n3.1 Acceptable Use Policy\nCompany IT resources are provided for business purposes."
    ]
  },
  {
    "question": "What is the classification of sensitive business information?",
    "answer": "Confidential",
    "supporting_passages": [
      "Employees must:\n- Use strong, unique passwords and enable multi-factor authentication\n- Report any security incidents immediately\n- Avoid downloading unauthorized software\n- Refrain from accessing inappropriate content\n- Protect sensitive information when working remotely\nMonitoring: The organization reserves the right to monitor IT resource usage \nto ensure compliance with policies and protect company assets. 3.2 Data Classification and Handling\nData is classified into four categories:\n1. Public: Information approved for public release\n2. Internal: General business information\n3. Confidential: Sensitive business information\n4. Restricted: Highly sensitive information requiring special handling\nEach classification level has specific handling, storage, and transmission \nrequirements that employees must follow. 4. Code of Conduct\nAll employees are expected to adhere to the highest ethical standards in their \nprofessional conduct. This includes:\n- Acting with integrity and honesty in all business dealings\n- Avoiding conflicts of interest and disclosing potential conflicts\n- Protecting company assets and using them responsibly\n- Maintaining confidentiality of proprietary information\n- Treating colleagues, clients, and partners with respect and dignity\n- Complying with all applicable laws and regulations\nViolations of the code of conduct may result in disciplinary action, up to and \nincluding termination of employment."
    ]
  },
  {
    "question": "What is the classification of sensitive information?",
    "answer": "Confidential",
    "supporting_passages": [
      "Employees must:\n- Use strong, unique passwords and enable multi-factor authentication\n- Report any security incidents immediately\n- Avoid downloading unauthorized software\n- Refrain from accessing inappropriate content\n- Protect sensitive information when working remotely\nMonitoring: The organization reserves the right to monitor IT resource usage \nto ensure compliance with policies and protect company assets. 3.2 Data Classification and Handling\nData is classified into four categories:\n1. Public: Information approved for public release\n2. Internal: General business information\n3. Confidential: Sensitive business information\n4. Restricted: Highly sensitive information requiring special handling\nEach classification level has specific handling, storage, and transmission \nrequirements that employees must follow. 4. Code of Conduct\nAll employees are expected to adhere to the highest ethical standards in their \nprofessional conduct. This includes:\n- Acting with integrity and honesty in all business dealings\n- Avoiding conflicts of interest and disclosing potential conflicts\n- Protecting company assets and using them responsibly\n- Maintaining confidentiality of proprietary information\n- Treating colleagues, clients, and partners with respect and dignity\n- Complying with all applicable laws and regulations\nViolations of the code of conduct may result in disciplinary action, up to and \nincluding termination of employment."
    ]
  },
  {
    "question": "What does Elite Dynamics Partners do with personal data?",
    "answer": "protecting the privacy and security",
    "supporting_passages": [
      "Reporting Mechanisms:\nEmployees can report concerns through their manager, HR department, or the \nanonymous ethics hotline. The organization prohibits retaliation against \nindividuals who report concerns in good faith. 5. Data Protection & Privacy Policies\nElite Dynamics Partners is committed to protecting the privacy and security of \npersonal data in accordance with applicable data protection laws. Data Protection Principles:\n- Lawfulness, fairness, and transparency in data processing\n- Purpose limitation: Data collected for specified, legitimate purposes\n- Data minimization: Collecting only necessary data\n- Accuracy: Keeping data accurate and up-to-date\n- Storage limitation: Retaining data only as long as necessary\n- Integrity and confidentiality: Implementing appropriate security measures\n- Accountability: Demonstrating compliance with data protection principles\nData Subject Rights:\nIndividuals have rights regarding their personal data, including access, \nrectification, erasure, and data portability. Requests should be submitted \nto the Data Protection Officer. International Data Transfers:\nWhen transferring data internationally, the organization ensures adequate \nprotection through appropriate safeguards such as Standard Contractual Clauses. 6."
    ]
  },
  {
    "question": "What does Elite Dynamics Partners do with their personal data?",
    "answer": "protecting the privacy and security",
    "supporting_passages": [
      "Reporting Mechanisms:\nEmployees can report concerns through their manager, HR department, or the \nanonymous ethics hotline. The organization prohibits retaliation against \nindividuals who report concerns in good faith. 5. Data Protection & Privacy Policies\nElite Dynamics Partners is committed to protecting the privacy and security of \npersonal data in accordance with applicable data protection laws. Data Protection Principles:\n- Lawfulness, fairness, and transparency in data processing\n- Purpose limitation: Data collected for specified, legitimate purposes\n- Data minimization: Collecting only necessary data\n- Accuracy: Keeping data accurate and up-to-date\n- Storage limitation: Retaining data only as long as necessary\n- Integrity and confidentiality: Implementing appropriate security measures\n- Accountability: Demonstrating compliance with data protection principles\nData Subject Rights:\nIndividuals have rights regarding their personal data, including access, \nrectification, erasure, and data portability. Requests should be submitted \nto the Data Protection Officer. International Data Transfers:\nWhen transferring data internationally, the organization ensures adequate \nprotection through appropriate safeguards such as Standard Contractual Clauses. 6."
    ]
  },
  {
    "question": "What is the name of the document that is reviewed annually?",
    "answer": "Appendix E: Revision History",
    "supporting_passages": [
      "Appendices\nAppendix A: Emergency Contact Information\nAppendix B: Department-Specific Policies\nAppendix C: Forms and Templates\nAppendix D: Policy Acknowledgment Form\nAppendix E: Revision History\nThis document is reviewed annually and updated as necessary to reflect changes in laws, regulations, and business\npractices. The latest version is always available on the company intranet."
    ]
  },
  {
    "question": "What is the name of the document that is updated every year?",
    "answer": "Appendix E: Revision History",
    "supporting_passages": [
      "Appendices\nAppendix A: Emergency Contact Information\nAppendix B: Department-Specific Policies\nAppendix C: Forms and Templates\nAppendix D: Policy Acknowledgment Form\nAppendix E: Revision History\nThis document is reviewed annually and updated as necessary to reflect changes in laws, regulations, and business\npractices. The latest version is always available on the company intranet."
    ]
  }
]